1.*Shader Reference*
    *surface sharders*
    *vertex and fragment shaders*
    *fixed function shaders*
    裁剪：(?裁剪指的是哪个？此三个地方，都有书中说裁剪)
        Clipping
        Culling
        Scissor
    note:不同的参考资料中给出的流水线名、顺序可能不相同，一个原因是由于图像编程接口（eg.OpenGL和DirectX）的实现不同，
        另一个原因是GPU在底层可能做了很多优化（eg.Early-Z 提前深度测试）。
2.流程图
    1.shaderlab 

    Transform,TexGen,Lighting                   (Early-Z技术)       Texturing Fog
                                ------>  Culling DepthTest  ----->                  ----->  Alpha Test ------> Blending
    Vertex Shader                                                   Fragment Shader 

    2.图形硬件流水线

                顶点连接信息
            -------------------------
                                    |                           (Colored Fragments)
                                    ↓         片段                   着色片段
        ---> 顶点变换   --->   图元装配和光栅化 ---> 片段纹理映射和着色 ---> *光栅化操作* --->
         顶点         被变换的顶点  |                                           ↑           更新像素
      (Vertices)                    ↓                                           |
                                    ---------------------------------------------

    3.光栅化操作

                                                    (Scissor Test)    (Alpha Test)   (Stencil Test)    (Depth Test)          (Blending)  (Dithering)    (Logic Op)        (Color Buffer)
        片段和与之相关联的数据  --→ 像素所有权测试  --→ 裁剪测试    --→ alpha测试   --→ 模板测试    --→   深度测试   --------→ 混合   --→ 抖动显示    --→ 逻辑操作    --→ 颜色缓冲区
                                                                                          |                |   |                 ↑                                               |
                                                                                          |      模板      |   |                 |                                               |
                                                                                          ---→  缓冲区  ←---   --→深度缓冲区      -------------------------------------------------
                                                                                            (Stencil Buffer)   (Depth Buffer)
    4.可编程图形流水线(The Programmable Graphics Pipeline)

                  3D应用程序或游戏
                        |
            3D API      |
           Commands     |
                        ↓
                    3D API:
                OpenGL或Direct3D
                        |                                       CPU-GPU Boundary
        ================|==============================================================================================================================================================================
                        |
           GPU Command  |                                                           Assembled Polygons
          & DataStream  |               Vertex Index Stream                             ,Lines&Points                                   Pixel Location Stream                Pixel Updates
                        |                  (顶点索引流)                           (装配后的多边形、线段和点)                                (像素位置流)                       (像素更新)
                        ↓
                 GPU Front End  ------------------------→ Pirmitive Assembly --------------------------------→ Resterization&Interpolation -----------------→ Raster Operations ---------→ Frame Buffer
                 (GPU 前端)                                 (图元装配)                                             (光栅化和插值)                              (光栅化操作)                 (帧缓冲)
                       |                                        ↑                                                         |                                         ↑
    Pretransformed     |                                        |   Transformed                Rasterized Pretransformed  |                                         | Transformed Fragments
      Vertices         |                                        |     Vertices                      Fragments             |                                         |    (变化后的片段)
    (变换前的顶点)     |                                        |  (变换后的顶点)                (光栅化的变化前的片段)   |                                         |
                       |                                        |                                                         |                                         |
                       -----→ Programmable Vertex Processor -----                                                         ------→ Programmable Fragment Processor ---
                                (可编程顶点处理器)
3.固定管线和可编程流水管线
<<Cg教程>>                                
note:有一些地方不是很明白。（眼空间那块。。。）
1.图形硬件流水线
    一个流水线是一序列可以并行和按照固定顺序进行的阶段。
    每个阶段都从它的前一阶段接收输入，然后把输出发给随后的阶段。

            顶点连接信息
        -------------------------
                                |
                                ↓         片段                   着色片段
    ---> 顶点变换   --->   图元装配和光栅化 ---> 片段纹理映射和着色 ---> 光栅化操作 --->
     顶点         被变换的顶点  |                                           ↑
                                ↓                                           |
                                ---------------------------------------------
    顶点(vertex)信息:
        位置                                position
        颜色                                color
        第二(反射)颜色  
        纹理坐标集(一个或多个)
        法向量                              normal
    1.顶点变换
        模型顶点位置变化到屏幕位置（以便光栅器使用）
        为贴图产生纹理坐标
        照亮顶点以决定顶点的颜色(?和光照有关)
    2.图元装配和光栅化
        图元装配阶段：
            将顶点装配为几何图元:根据伴随顶点序列的几何图元分类信息把顶点装配成几何图元
            输入：
                顶点序列
            过程：
                图元装配: 产生一序列的 三角形、线段和点
                    几何图元的类型：
                        点,独立的线段,循环线段,线段带
                        独立的三角形,三角带，三角扇
                        独立的四边形，四边形带，多边形
                裁剪:经过裁剪到可是*平截体*和任何有效的应用程序制定的*裁剪平面*
                culling(挑选):*光栅器*根据多边形的朝前或朝后来丢弃一些多边形。
            输出：
                多边形

        光栅化：
            决定哪些像素被几何图元覆盖的过程。
            多边形、线段和点根据每种图元指定的规则分别被光栅化。
            光栅化的结果是像素位置的集合和片段的集合
            输入：
                经过裁剪和culling的多边形
            过程：
                光栅化测试
            输出：
                像素位置的集合和片段的集合
            光栅化后，一个图元拥有的顶点数目和产生的片段之间没有任何关系。(顶点数和到了屏幕上的片段，没有关系)
        像素：图像元素的简称。代表帧缓存这种某个指定位置的内容。（eg.颜色，深度和其他与之歌位置相关联的值）
        片段(Fragment):一个片段是更新一个特定像素前在需要的一个状态.
            像素位置、深度值、
            经过插值的参数:颜色、第二（反射）颜色，一个或多个纹理坐标集
    3.插值、贴图和着色
       一个图元被光栅化成为片段的时候，如果片段属性需要，才进行插值、贴图和着色阶段.
       除了确定片段的最终颜色，这个阶段还新确定一个深度，或者甚至丢弃这个片段以避免更新帧缓存对应的像素。
       允许这个阶段可能丢弃片段，这个阶段为它接收到的每个输入片段产生一个或不产生着色过的片段。
       1.为片段：插值、着色（颜色）、产生深度
       2.丢弃片段
    4.光栅操作
        在最后更新帧缓存之前。执行最后一系列的针对每个片段的操作。
        此阶段：
            深度测试：消除隐藏面
            混合(blend):
            模板(stencil)：
            阴影:
        光栅操作阶段将根据许多测试来检测每个片段：
            裁剪：
            alpha:
            模板：
            深度测试：
        如果任意一项测试失败了，片段就会在这个阶段被丢弃,而更新像素的颜色纸（虽然一个模板写入的操作也许会发生）。
        通过了深度测试，就可以用片段的深度值代替像素的深度值了。
        在测试之后，混合操作将把片段的最后颜色和对应的像素的颜色结合在一起。


        片段和与之相关联的数据  --→ 像素所有权测试  --→ 裁剪测试    --→ alpha测试   --→ 模板测试    --→ 深度测试    --------→ 混合    --→ 抖动显示    --→ 逻辑操作    --→ 颜色缓冲区
                                                                                          |                |  |                 ↑                                               |
                                                                                          |      模板      |  |                 |                                               |
                                                                                          ---→  缓冲区  ←---  --深度缓冲区      -------------------------------------------------
2.可编程图形流水线(The Programmable Graphics Pipeline)
                  3D应用程序或游戏
                        |
            3D API      |
           Commands     |
                        ↓
                    3D API:
                OpenGL或Direct3D
                        |                                       CPU-GPU Boundary
        ================|==============================================================================================================================================================================
                        |
           GPU Command  |                                                           Assembled Polygons
          & DataStream  |               Vertex Index Stream                             ,Lines&Points                                   Pixel Location Stream                Pixel Updates
                        |                  (顶点索引流)                           (装配后的多边形、线段和点)                                (像素位置流)                       (像素更新)
                        ↓
                 GPU Front End  ------------------------→ Pirmitive Assembly --------------------------------→ Resterization&Interpolation -----------------→ Raster Operations ---------→ Frame Buffer
                 (GPU 前端)                                 (图元装配)                                             (光栅化和插值)                              (光栅化操作)                 (帧缓冲)
                       |                                        ↑                                                         |                                         ↑
    Pretransformed     |                                        |   Transformed                Rasterized Pretransformed  |                                         | Transformed Fragments
      Vertices         |                                        |     Vertices                      Fragments             |                                         |    (变化后的片段)
    (变换前的顶点)     |                                        |  (变换后的顶点)                (光栅化的变化前的片段)   |                                         |
                       |                                        |                                                         |                                         |
                       -----→ Programmable Vertex Processor -----                                                         ------→ Programmable Fragment Processor ---
                                (可编程顶点处理器)
3.光照和光照模型
    .光照和一个物体的材质特性一起决定了物体的外观
    .光照模型根据光和物体的特征，描述了光和物体之间的相互作用和影响
    .基本的光照模型：
                      光照      放射光  (Emissive) (自发光)
        物体表面颜色 ------→ {  环境反射(Ambient)
                      材质      漫反射  (Diffuse)
                                镜面反射(Specular)
        SurfaceColor=Emission + Ambient + Diffuse + Specular
        1.放射光 Emissive
            由物体表面发出的光，不影响其他物体
            模拟炽热物体
            计算完其他所有光照后，添加此颜色
            Emissive=Ke (Ke为材质的放射光颜色)
        2.环境反射 Ambient
            不依赖与光源的位置，来自四面八方
            受全局环境光的影响
            SurfaceColor的Ambient项依赖于材质的反射能力和环境光的颜色
            Ambient=Ka*GlobalAmbient    (Ka为材质环境光反射系数，GlobalAmbient为入射环境光的颜色)
        3.漫反射 Diffuse
            Diffuse=Kd*lightColor*max(N·L,0)
            Kd:材质的漫反射颜色
            lightColor:入射漫反射光的颜色
            N:单位表面法向量
            L:单位指向光源的向量
            P:被着色的点
        4.镜面反射 Specular
            依赖于观察者的位置，得能接收到反射光线
            受光源、材质的镜面反射性质和表面光泽度的影响
            （越由光泽的材质高光区越小，较少光泽的材质高光区越分散的开）
            Specular=Ks*lightColor*facing*pow((max(N·H),0),shininess)
            Ks:材质的镜面反射颜色
            lightColor:入射镜面反射光的颜色
            N:单位表面法向量
            V:视点的单位向量
            L:光源方向的单位向量
            H:V和L的中间向量的单位向量  H=(V+L)*0.5
            P:要着色的点
            facing:若N·H>0，则为1；否则为0
                （朝向。是否与Normal朝向相同，同方向才有作用。也就是漫反射光是否大于0，没有漫反射，自然也就没有镜面反射）
    .对光照模型的简化：
        所有光源共用一个全局环境颜色
        漫反射光和镜面反射光使用同一个颜色
        没有引入衰减或聚光灯效果
4.扩展光照模型
    1.距离衰减
        AttenuationFactor=1/(Kc+Kld+Kqd²)
        d：到光源的距离
        Kc,Kl,kq:控制衰减的常量
        常数项，一次系数，二次系数
        模拟真实世界中，一个点光源的强度以1/(d²)衰减，更多参数，更多控制
        衰减因子用于调整漫反射和镜面反射项
        lighting=Emission+Ambient+AttenuationFactor*(Diffuse+Specular)
    2.聚光灯效果
        (p123)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<<Untiy3d ShaderLab>>
note:豆瓣评这本书挺烂的，我也这么认为。很多内容都不符合标题要说的东西。概念也不说,或者有的说的也有问题。在没有弄清楚之前，还是不看这个了。
1.Shader结构
    Shader，定义文件名

    Shader "ShaderName"
    {
        Properties
        {
        }
        SubShader
        {
            Tags { "Queue"="Geometry" "RenderType"="Opaque" "IgnoreProjector"="True"}
            Pass
            {
                Name "PASS_NAME"  //可以被其他Shader引用,必须大写
                //eg.
                //UsePass "ShaderName/PASS_NAME"
            }
            Pass{}
            ...
        }
        SubShader
        {
        }
        ...
        FallBack "Default Shader Name"
    }
    1.SubShader用于编写不同显卡的处理 
        SubShader包装了一个渲染方案，而这个渲染方案是由一个个Pass块执行的。
        如果只有一个Pass,可以省略，写在SubShader块中
    2.SubShader的重要标签 Tags{}块
        Queue:
            Background      1000
            Geometry        2000
            AlphaTest       2450
            Transparent     3000
            Overlay         4000
        RenderType:
            Opaque
            Transparent
            TransparentCutout
            Background
            Overlay
            在替代渲染（Placement)做Post Effects时很重要，Unity内置的Image Effects根据它来决定如何替代渲染
            此外，如果相得到场景的一张ZDepth和Normals的快照，也需要一个正确的RenderType
        IgnoreProjector:
            True       当前物体忽略Projector的影响
            False

        自定义标签：
            eg. "MyTag"="Lucifer" 一般在替代渲染时用到（用于区分类别）
    3.SubShader中的 Pass{}块
        Pass中包含了渲染一个集合体的具体代码
        Pass块中的标签都是针对*渲染路径*的，告诉渲染引擎这个Pass在什么渲染路径下被渲染。
        Name 用于定义Pass的名字，以便别的shader可以引用，必须大写
        UsePass 用于引用Pass,路径为 shaderName/PASS_NAME
    4.FallBack保证Shader的广泛适用性
        如果用户所有的SubShader都失败了，为了在用户计算机上呈现设置的机制，使用FallBack指定所用的Shader。
2.ShaderLab支持的语言
    1.使用GLSL写Shader逻辑
        代码必须位于GLSLPROGRAM和ENDGLSH关键字之间
    2.使用Cg/HLSL
        代码必须位于CGPROGRAM和ENDCG关键字之间
3.Unity3d中Shader的3中形态
    1.固定管线 (Fixed Pipeline)
        应对老一代GPU，没有可编程流水管线的情况下使用。
        固定管线的形态和语法和NVIDIA的CgFX以及微软的FX文件比较类似。
        固定管线的相关代码都必须处于一个Pass块中。
    2.可编程Shader
        在Pass块中，编写顶点和片段程序
        Pass
        {
            CGPROGRAM
            #pragma vertex vert     //声明vertext Shader的函数为 vert
            #pragma fragment frag   //声明fragment Shader的函数为 frag
            #include "UnityCG.cginc"    //引用外部文件
            ...vert(...){}
            ...frag(...){}
            ENDCG
        }
        除此之外，还可以使用一些指令告诉Unity如何具体地编译Shader:
        1.#pragma target 2.0 
        :编译目标2.0，相当于Direct3D的Shader Model 2.0
        :对应与OpenGL下的
            256条ARB_vertex_shader的指令，
            32条ARB_fragment_shader的texture指令和
            64条普通指令，
            16个寄存器和
            4个贴图

        2.#pragma target 3.0  
        :编译目标3.0，相当于Direct3D的Shader Model 3.0
        :对应与OpenGL下的
            ARB_vertex_shader没有指令书目限制
            512条ARB_fragment_shader的texture指令和
            512条普通指令，
            32个寄存器和
            4个贴图
        3.对于面向OpenGL接口的情况，还可以使用
                #pragma profileoption MaxTexIndirection=256
            这样的指令。
            当编译平台为独立的可执行桌面OpenGL程序时，可以使用
                #pragma glsl
            把Cg代码转换为GLSL代码，从而绕过在Shader Model 3.0中的一些指令限制
        4.使用#pragma fragmentoption option来限制编译出的fragment函数
        5.#pragma glsl_no_auto_normalization
            对于移动平台GLSL,例如Android和IOS,用此来关闭vertex函数中对法线和且想了的自动单位化处理
        6.限制编译平台
            #pragma only_renderersd3d9 gles
            #pragma exclude_renderers xbox360
            适应于这两条指定的值有：d3d9,d3dll,opengl,gles(移动平台的OpenGL),xbox360,p3(任天堂的PlayStation),flash
    3.Surface Shader
        Unity通过Surface Shader把一些复杂性包装了起来，包括：
        处理不同的照明、点光源、平行光、光照贴图等
        处理不同的阴影选项
        在Unity的两个渲染路径(Forward和Deferred)下正常工作

        1.Surface Shader结构:
            最终会编译为一个复杂的vertex+fragment Shader.
            写在Pass块中（如果只有一个Pass,可以省略，写在SubShader块中）

            CGPROGRAM
            #pragma surface surf Lambert    //表面函数为surf,使用光照模型为Lambert
            ...
            void surf (Input IN, inout SurfaceOutput o){}
            ENDCG

            其中SurfaceOutput：
            struct SurfaceOutput
            {
                half3 Albedo;       //颜色纹理
                half3 Normal;       //法线
                half3 Emission;     //自发光，不受照明的影响
                half Specular;      //高光指数
                half Gloss;         //光泽度
                half Alpha;         //透明度,Alpha 通道
            }
4.Shader的数据接口 属性和uniform变量
    1.定义属性值
        Properties
        {
            _MyTexture ("Texture (RGB)", 2D) = "white" {}       //texture property
            _MyColor ("Color of Object", Color) = (1,1,1,1)     // color property
            _MyCube ("Environment map", Cube ) = "white"{}      //3d texture property(cube map),need 6 textures
            _MyVector ("Vector", vector) = (1,1,1,1)            //vector property
            _MyFloat ("Float Value", float) = 1.0               //float property
            _MyRange ("Another type of float", range(-10,10))=1.0   //float property with range
        }

        _VarName("inspector show name", varType) = default value
    2.在脚本中操控Material属性
        Material的方法中有获取和设置属性的接口
        public Material mat;

        mat.SetXXX("property Name",value)
        mat.GetXXX("property Name")

        Set/GetTexture
        Set/GetColor
        Set/GetTexture
        Set/GetFloat
    3.矩阵
    不能在属性块中定义
    可以在Shader中对一个矩阵进行声明，Material中有Get/SetMatrix的接口
    uniformfloat4x4 myMatrix;

    mat.SetMatrix("myMatrix",matrix);
    mat.GetMatrix("myMatrix");

    4.在Cg代码中使用属性
        在Cg代码中声明：
        CgVarType _VarName;     //varType _VarName

        CgVarType       varType;
        sampler2d       2D
        samplerCUBE     Cube
        float4          Color
        float4          vector
        float           float
        float           range(n,m)

        此外，数据类型中有：
        float       float4      32位
        half        half4       16位
        fixed       fixed4      8位
5.空间概念
    ref:OpenGL
        计算机图形的要点是，创建三维物体的二维图像。
        尽量在三维空间中想象物体的形状。
        为把一个物体的三维坐标变换为屏幕上的像素坐标,需要以下3个步骤：
        1.变换。
            包括模型、视图和投影操作。它们是由矩阵乘法表示的，这些操作包括旋转、移动、缩放、反射、正投影和头饰投影。
            一般情况下，在绘制场景时，需要组合使用几种变换。
        2.裁剪。
            由于场景时在一个矩形窗口中渲染的，因此位于窗口之外的物体（或物体的一部分）必须裁剪掉。
            在三维计算机图形中，裁剪就是丢弃位于裁剪平面之外的物体。
        3.视口变换
            最后，经过了变换的坐标和屏幕像素之间必须建立对应关系。这个过程称为视口变换。
            把三维的模型坐标转换为屏幕坐标
        
    1.*模型空间*(Model Space)
        模型物体都有一个以它自己的Pivot为原点的三维坐标空间。
        相对于模型自己的Pivot为原点的空间，叫做模型空间。
        模型空间在处理物体自身的一些相对关系时比较有用，eg.自身的面、线、点等。

        从*世界空间*到*模型空间*的转换：
        脚本中：
        transform.woldToLocalMatrix     //transform的世界空间到模型空间的转换矩阵
        transform.worldToLocalMatrix.MultiplyPoint(Vector3 v);      //将v点转化到transform的模型空间的位置
        transform.worldToLocalMatrix.MultiplyVector(Vector3 v);     //将v方向向量转到transform的模型空间向量
        Shader中：
        左乘_World2Object矩阵
    2.*世界空间*
        3D
        以世界坐标空间作为统一表达。
        当有多个物体的时候，所有物体使用世界空间坐标系来表达相对关系、位置、大小、旋转。

        从*模型空间*到*世界空间*的转换:
        脚本中：
        transtorm物体自身以模型空间坐标表达式的矢量变换到实践坐标表达式的矩阵和方法
        transform.localToWorldMatrix     
        transform.localToWorldMatrix.MultiplyPoint(Vector3 v);      
        transform.localToWorldMatrix.MultiplyVector(Vector3 v);     
        Shader中：
        左乘_Object2World矩阵
    3.*视空间*
        3D
        视空间又称为相机空间，为了方便表达以*相机为参考中心*时所有物体的相互关系的一个空间。

        从*世界空间*变换到*视空间*：
        脚本：
        通过Camera组件的worldToCameraMatrix,将一个世界坐标向量变换为以此相机为中心的空间表达式
        Camera.cameraToWoldMatrix，将以此相机空间的坐标系转换到世界坐标系
        Shader:
        使用矩阵UNITY_MATRIX_MV将向量从*模型空间*转到*视空间*
        MV:Model to View
    4.*视锥体*
        3D
        视锥体是看得到的部分。也即存在于相机的视锥体中,即存在于镜头中。
        只有处于视锥体内的物体才会被渲染，也就是在屏幕上能看到的东西。
        视锥体是由远近裁剪屏幕以及视角大小所顶一个的一个平头锥体，而相机处于锥体的顶点上。
        这个剔除掉视锥体以外的物体的过程，叫做Culling.
    5.*剪切空间*
        3d-->2d
        从视锥体（视线平截体，代表了眼空间中物体的可见区域），到2D屏幕上的坐标变换。
        这个过程的变换叫做*投影变换*
        (将3d物体投影到2d屏幕上？）
        从视锥体的三维空间，到二维平面上，需要首先进行一次*投影*,把视锥体变为一个长方体。
        这次变化是vertex Shader任务的重点。之后的引擎会自动处理下面的事情，把坐标转到NDC(Normalized Device Coordinates).
        这是一个无量纲的空间，OpenGL和Direct3D稍有不同:
        OpenGL 值域 （-1，-1，-1）到 （1,1,1）
        Direct3D值域 （-1,0，-1）到（1,1,1，）
        变换：
        脚本：
        (?从世界空间，到相机的投影空间的投射矩阵？？)
        此投影操作是Camera组件的projectionMatrix
        Shader:
        从模型空间投影到屏幕上
        UNITY_MATRIX_MVP
        MVP: Model View Projection
6.基本的光照模型
    1.光源对物体照明的分类
        间接照明:
        光在物体间传播后，最终又对物体形成的照明。
        eg.通过光线跟踪，光线多次反弹对物体进行照明。
        一般光线用烘焙lightmap和lightprob的方式进行，不做实时计算。
        直接照明：
        不考虑光线在物体间的传播，也不考虑光线在物体内部传播，光线对物体直接照明
            分为两种：
            .漫反射
            .镜面反射
                形成强烈高光
        直接照明是实时渲染的计算重点。
    2.Unity中的光照模型
        1.漫反射和Lambert
            .漫反射
                对于粗糙物体表面的某一点，其亮度应该和入射光线与该点的垂直程度相关，也就是入射光线与此法线的夹角相关。
                如果，用L代表单位长度的入射光线，C代表达到此点的光线的强度和颜色，N代表此点的法线，则物体表面此点的亮度Lum表示为:
                Lum=C*max(0,cos<L,N>)
                   =C*max(0,L·N)
                <L,N>表示矢量L和N之间的夹角。
                实际计算L·N可以用Cg标准库函数 dot(L,N)计算。
                使用max(0,value)来控制，如果是背光，最终结果不能为负值。
            .Lambert
                没有高光,适合制作橡胶类的东西
            可以把按照这种方式对物体进行照明计算的模型叫做*Lambert*
            Surface Shader中有两个内置的Lighting Model函数:
            LightLambert()                      Forward渲染路径下的Lambert光照方式
            LightingLambert_PrePass()           Deferred渲染路径下的Lambert光照方式
            位于Editor/Data/CGIncludes/Lighting.cginc文件中,函数如下：
            inline fixed4 LightLambert (SurfaceOutput s,fixed3 lightDir,fixed atten)
            {
                fixed diff=max(0,dot(s.Normal,lightDir));   //对漫反射的计算
                fixed4 c;
                //计算物体表面的纹理颜色、光源颜色以及光源强度的影响
                c.rgb=s.Albedo * _lightColor0.rgb * (diff * atten *2);
                c.a=s.Alpha;
                return c;
            }
            note:Unity5.x此函数发生了变换，可以添加多个光照的漫反射光
        2.镜面高光和Phong
            .镜面高光
                某一光线ray在某一法线为normal的点，反射后的光线，使用Cg标准库中的reflect(ray,normal)进行计算
                如果用R表示光线在此点的单位长反射方向向量，V表示视线的单位方向向量，gloss表示表面的镜面光滑程度，
                那么高光Spec计算方式为:
                Spec=pow(max(0,cos<V,N),gloss)
                    =pow(max(0,dot(V,N),gloss)
            .Phong
                有高光
                ref 百度：
                Phong光照模型分为三个累加阶段：漫反射，镜面反射和环境光
            Lambert的漫反射加上镜面高光，就是Phong
                c.rgb=s.Albedo * _lightColor0.rgb * ((diff+Spec) * atten *2);
            note:这个书里面说的不完全正确,需要参考其他书籍
        3.半角向量和BlinnPhong
            在上面高光计算的方式中，计算了一次入射光线的反射，然后考察此反射光线进入视野的程度。
            另外一种更简单、更易于调节的方式是，使用入射光线和视线的中间平均值，即*半角向量*，然后使用此半角向量和法线计算出一个和视角相关的高光。
            此种高光计算方式为*BlinnPhong*
            Surface Shader中有两个内置的Lighting Model函数:
            LightingBlinnPhong()                    Forward渲染路径下的BlinnPhong光照方式
            LightingBlinnPhong_PrePass()            Deferred渲染路径下的BlinnPhong光照方式
            位于Editor/Data/CGIncludes/Lighting.cginc文件中,函数如下：
            inline fixed4 LightingBlinnPhong (SurfaceOutput s,fixed3 lightDir,half3 viewDir,fixed atten)
            {
                half3 h=normalize(lightDir+viewDir);
                fixed diff=max(0,dot(s.Normal,lightDir));
                float nh=max(0,dot(s.Normal,h));
                float spec=pow(nh,s.Specular*128.0) * s.Gloss);

                fixed4 c;
                c.rgb=(s.Albedo*_LightColor0.rgb*diff+_LightColor0.rgb*_SpecColor.rgb*spec)*(atten*2);
                c.a=s.Alpha+_LightColor0.a*_SpecColor.a*spec*atten;
                return c;
            }
7.Unity中的照明
    1.渲染路径和Pass的LightMode标签
        Unity支持3种*RenderingPath*(*渲染路径*),分别为VertexLit,Forward和Deferred Lighting.
        为此，在Pass中使用的*LightMode*标签Vertex,ForwardBase,ForwardAdd,PrepassBase,PrepassFinal等，分别表示当前Pass是在哪个RenderingPath下设计使用。
    2.设计可以检测渲染路径的材质

<<Shader 入门精要>>
note:知乎推荐，初步看了下，很好的书.从基础讲起，建立读者对渲染流程的基本认识。
源码地址：https://github.com/candycat1992/Unity_Shaders_Book
.基础部分
1.渲染流水线
    三维场景--→二维纹理。
    1.渲染流程的3个阶段：
        .应用阶段（Application Stage)
        .几何阶段（Geometry Stage）
        .光栅化阶段（Rasterizer Stage）
        每个阶段通常也是一个流水系统，即包含了自流水线阶段。

        应用阶段 ------------→ 几何阶段 --------------→ 光栅化阶段
            ↓                   ↑    ↓                      ↑
            ↓                   ↑    ↓                      ↑
            --→ 输出渲染图元 ----    -----→ 输出屏幕空间 ----
                                             的顶点信息
        .应用阶段
            CPU实现。开发者可以控制。
            输入：
                1.准备好场景数据。
                    eg.Camera位置，视锥体设置，场景中的模型，光源
                2.粗粒度剔除(culling)
                    把不可见物体剔除
                3.设置每个模型的渲染状态
                    渲染状态包括但不限于材质（漫反射颜色、高光反射颜色）、使用纹理、使用的Shader等。
            处理过程：
                1.把数据加载到显存中
                    网格和纹理从内存中，加载到显存(Video Random Access Memory,VRAM)中
                2.设置渲染状态
                    设置网络应该被怎样渲染。
                    eg.设置使用哪个着色器、光源属性、材质等。
                3.调用Draw Call
                    DrawCall,从CPU发起，将一次需要渲染的图元列表(?是Display List吗)发送到GPU进行渲染。
            输出：
                渲染所需的几何信息，即*渲染图元*(*rendering primitives*)
                渲染图元可以是点、线、三角面等。
        .几何阶段(GPU流水线)
            在GPU上进行。处理每个渲染图元，进行逐顶点、逐多边形的操作（？逐多边形操作？？感觉有问题）
            输入：
                渲染图元
            处理：
                顶点坐标变换到屏幕空间,再交给光栅器进行处理。
            输出:
               渲染图元在屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色信息。 
        .光栅化阶段(GPU流水线)
            在GPU上进行。
            光栅化的主要任务是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。
            对上一个阶段得到的逐顶点数据进行插值，再进行片段处理。
            输入：
                上一阶段的(二维)顶点信息
            处理：
                1.逐顶点数据插值，得到片段
                2.光栅化操作(各种测试和混合什么的)
            输出：
                屏幕上的像素
    2.GPU流水线
        简易流程图：
            几何阶段
                   -------------------------------------------------------------------------------
                   |  (可编程控制)     (可编程控制)       (可编程控)     (可配置)  (GPU固定实现) |
                   |                      (可选)            (可选)                               |
        顶点数据 --|-> 顶点着色器 ---> 曲面细分着色器 ---> 几何着色器 ---> 裁剪 ---> 屏幕映射    |
                   |                                                                     |       |
                   |                                                                     |       |
                   ----------------------------------------------------------------------|--------
                                                                                         |
                        ------------------------------------------------------------------
                        |
        光栅化阶段 -----|---------------------------------------------------------
                   |    ↓                                                        |
                   | 三角形设置 ---> 三角形遍历 ---> 片元着色器 ---> 逐片元操作 -|-> 屏幕图像
                   |(GPU固定实现)   (GPU固定实现)   (可编程控制)     (可配置)    |
                   |                                   (可选)                    |
                   ---------------------------------------------------------------

        几何阶段：
        .顶点着色器(Vertex Shader)
            完全可编程。通常用于实现顶点的空间变换、顶点着色等功能。
            顶点输入来源于CPU,输入进来的每一个顶点都会调用一次顶点着色。
            顶点着色器不会创建顶点，也无法得到顶点与顶点的关系。
            主要完成：坐标变换和*逐顶点光照*。可以修改顶点的其他信息。
                坐标变换：
                    可以改变顶点在坐标，这在*顶点动画*中非常有用。可以通过改变顶点位置来模拟水面、布料。
                    必须完成的一工作，就是把*顶点坐标*从*模型空间*转换到*齐次裁剪空间*。所以，顶点着色其中一般都有以下代码，
                        o.pos=mul(UNTIY_MATRIX_MVP,v.position)
        .曲面细分着色(Tessellation Shader)
            可选。用于细分图元。
        .几何着色器(Geometry Shader)
            可选。被用于执行逐图元的着色操作，或被用于产生更多的图元。
        .裁剪(Clipping)
            可配置。将不在摄像机视野内的顶点裁剪掉，并剔除(culling)某些三角图元的面片。
            eg.自定义裁剪平面来配置裁剪区域；通过指令控制裁剪三角图元的正面还是背面（Cull Off|Front|Back）
            裁剪到视锥体内。
            一个图元和摄像机的视野关系有3中：完全在视野内、部分在视野内、完全不在视野内。
            完全在视野内：传递下去
            完全不在视野内：不传递下去
            部分在视野内：为图元和视野立方体框的交界处生成新的顶点,并且将在视野外的顶点去掉。这个过程就是裁剪（Clipping）.
        .屏幕映射(Screen Mapping)
            不可配置、不可编程
            把每个图元的x和y坐标(三维坐标)转换到屏幕坐标系（Screen Coordinates）(二维坐标)。与显示画面的分辨率有很大关系。
            把场景渲染到屏幕窗口中，屏幕窗口的最小坐标为（x₁,y₁）,大坐标为(x₂,y₂),其中x₁<x₂,y₁<y₂。
            场景经过上一步骤的裁剪,输入的坐标范围为（-1,1）,到屏幕上(范围与分辨率有关系)。因此，这是一个缩放的过程。
            输入的z坐标不会做任何处理。实际上，屏幕坐标系和z坐标一起构成了一个坐标系，叫做*窗口坐标系*（*Window Coordinates*）

                                                                        
                (1,1)                                                                  (x₂,y₂)    
                    -----------------                             -------------------------
                    |               |                             |                       |
                    |               |           屏幕映射          |                       | 
                    |               |     ----------------->      |                       | 
                    |               |                             |                       | 
                    -----------------                             |                       |
                                    (-1,-1)                       |                       |
                                                                  -------------------------
                                                               （x₁,y₁）

            note:OPenGL和DirectX的屏幕坐标系有差异。OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则把屏幕的左上角作为最小的窗口坐标值

                                                        (x,y)            (0,0)    
                                   -------------------------                  -------------------------
                                   |                       |                  |                       |
                                   |                       |                  |                       | 
                                   |                       |                  |                       | 
                                   |                       |                  |                       | 
                                   |                       |                  |                       |
                                   |                       |                  |                       |
                                   -------------------------                  -------------------------
                                （0,0）                                                          （x,y）
                                       OpenGL屏幕坐标                               DirectX屏幕坐标

            微软的窗口都使用了从左到右、从上到下的符合我们阅读习惯的方式。并且很多图像文件也是按照这种格式存储的。
        光栅化阶段：
            上一阶段的输出信息是顶点的屏幕坐标信息，以及其他的额外信息，如深度值（z坐标）、法线方向、视角方向等。
            光栅化阶段会计算每个图元覆盖了哪些像素，以及为这些像素计算颜色。
        .三角形设置(Triangle Setup)
            固定函数（Fixed-Function）阶段。
            计算光栅化一个三角网格所需要的信息。
            上一阶段输出的都是三角网格顶点(并没有三角形的边，只有顶点)。为了得到整个三角网格对屏幕像素的覆盖情况，需要计算每条边上的像素坐标。从顶点->三角形边界，叫做三角形设置。
        .三角形遍历(Triangle Traversal)
            固定函数（Fixed-Function）阶段。
            (插值生成片元的过程)
            此阶段会检查每个像素是否被一个三角网格所覆盖,并使用三角网格的3个顶点信息对整个覆盖区域的像素进行*插值*。如果覆盖了，就会生成一个*片元*（*fragment*）。
            这样一个找到哪些像素被三角网格覆盖的过程就是*三角形遍历*,也称为*扫描变换*（*Scan Conversion*）
            这一步骤的输出是一个片元序列。
        .片元着色器(Fragment Shader)
            完全可编程。用于实现逐片元的着色操作。
            在DirectX中，片元着色器被称为像*素着色器*（*Pixel Shader*）
            此步骤最终会输出为一个或多个颜色值。
            纹理采样在此步骤。纹理坐标也是插值得到的。
        .逐片元操作(Pre-Fragment Operations)
            可配置。负责执行很多重要的操作，eg.修改颜色、深度缓冲、进行混合
            （对应Cg教程中的光栅化操作Raster Operations）
            此步骤在OpenGL中叫做*逐片元操作*(*Pre-Fragment Operations*)，在DirectX中，叫做*输出合并阶段*（*Output-Merge*）
            主要任务：
                1.测试
                    决定每个片元的可见性
                    测试工作,eg.模板测试,深度测试
                2.混合(通过了测试的片元)
                    通过了测试的片元，就需要把这个片元的颜色和已经存储在颜色缓冲区中的颜色进行混合,最后再写入颜色缓冲区中。
                                                
                片元 ----> 模板测试 ---> 深度测试 ---> 混合 ---> 颜色缓冲区
           .测试和混合
                测试的过程比较复杂，并且不同的图形接口（OpenGL和DirectX）的实现细节不同。
                
                简化流程：

                                开始模板测试                                                  开始深度测试                            
                                     |                                                             |
                        否           ↓                                                否           ↓
                ----------- 是否开启了模板测试                                ----------- 是否开启了深度测试
                |                    |                                        |                    |
                |                    |  是                                    |                    |  是
                |                    ↓                                        |                    ↓
                |         比较参考值（使用读取掩码）                          |         比较该片元的深度值和已经
                |         和已经存在于模板缓冲区中的                          |         存在于深度缓冲区中的深度值
                |         模板值（使用读取掩码）                              |                    |
                |                    |                                        |                    |
                |                    ↓                                        |                    ↓
                |             得到模板测试结果                                |             得到深度测试结果
                |                    |                                        |                    |
                |                    ↓              否                        |                    ↓              否
                |             是否通过了模板测试 -----------                  |             是否通过了深度测试 ------------------
                |                    |                     |                  |                    |                            |                  
                |                    |  是            舍弃该片元              -------------------> |  是                        |
                |                    ↓                     |                                       ↓                         舍弃该片            
                |            根据状态设置更新              |                                   是否开启了     否                |            
                |            模板缓冲区中的值 <-------------                                    深度写入   -------------        |
                |            （使用掩码写入）                                                      |                   |        | 
                |                    |                                                             | 是                |        | 
                -------------------> |                                                             ↓                   |        | 
                                     ↓                                                         将深度值写              |        | 
                                模板测试结束                                                  入深度缓冲区             |        |
                                                                                                    |                  |        |
                                                                                                    | <-----------------        |
                                                                                                    ↓                           |
                                                                                              深度测试结束  <--------------------
                                
            1.模板测试（Stencil Test）
                *模板缓存区*（*Stencil Buffer*）
                如果开启了模板测试，GPU首先会读取(使用读取掩码)模板缓冲区中该片元位置的模板值,然后将该值和读取(使用读取掩码)到的*参考值*(*reference value*)进行比较,
                这个比较函数可以由开发者指定。
                Comp comparisonFunction(default is always)
                缓冲区模板值-参考值,满足条件的，通过测试。不满足条件的，舍弃该片元
                    Greater
                    GEqual
                    Less
                    LEqual
                    NotEqual
                    Always
                    Never
                无论是否通过了模板测试，都可以修改模板缓冲区，比如设置选项有，
                    Pass xxx          通过测试操作
                    Fail xxx          测试失败的操作
                    ZFail xxx         深度测试失败的操作(通过了模板测试，但是没有通过深度测试)
                    xxx表示Stencil Operation.
                    其中, Stencil Operation有:
                        Keep
                        Zero
                        Replace
                        IncrSat
                        DecrSat
                        Invert
                        IncrWrap
                        DecrWarp
                模板测试通常用于限制渲染区域。一些高级用法可以用于渲染阴影、轮廓渲染等。
            2.深度测试（*Depth Test*）
                *深度缓冲区*(*Depth Buffer*)
                片元通过了模板测试，会进入深度测试。
                如果开启了深度测试，GPU会把该片元的深度值和已经存在于*深度缓冲区*中的深度值进行比较。
                比较：片元深度值-深度缓冲区深度值,满足条件的通过测试。如果没有通过测试，就舍弃该片元。
                    ZTest xxx
                    Less
                    Greater
                    LEqual
                    GEqual
                    NotEqual
                    Always
                通常使用小于等于(LEqual),因为深度值小，距离摄像机距离近。
                如果通过了深度测试，并且开启了深度写入（ZWrite）,能覆盖深度缓冲区中的值。
                    ZWrite On|Off
                    note:透明效果和深度测试以及深度写入的关系非常密切。
            3.混合/合并（Blend）
                片元通过了上面的测试，会来到混合/合并阶段。
                *颜色缓冲区*（*Color Buffer*）
                每个像素的颜色信息都被存储在一个名为颜色缓冲的地方。最终屏幕上显示的颜色，也是从颜色缓冲中得到的。
                是否开启*混合*(Blend)，影响本次片元的渲染是否要覆盖颜色缓冲区。
                note:因此，半透明物体一定要开启混合呀
                混合操作流程图：
                                                开始混合
                                                   |
                                                   ↓            否
                                             是否开启了混合 -------------------------------
                                                   |                                      |
                              (Src)                | 是             (Dst)                 |
                            得到源颜色 <-----------|-----------> 得到目标颜色             |
                           (片元的颜色值)                      (已经存在于颜色缓          |
                                |                               冲区中的颜色值)           |
                                |                                    |                    |
                                |                                    |                    |
                                -----------> 进行混合操作 <-----------                    |
                                                  |                              直接使用该片元的颜色值
                                                  |                                       |
                                                  ↓                                       |
                                            更新颜色缓冲区 <-------------------------------
                                               中的值
                                                  |
                                                  ↓
                                              混合结束
                如果没有开启混合，片元的颜色会直接覆盖颜色缓冲区中的颜色，这也是初学者无法得到透明效果的原因。
                如果开启了混合，GPU会去除源颜色和目标颜色，进行混合。
                    源颜色：片元着色器得到的颜色值
                    目标颜色：已经存在于颜色缓冲区中的颜色值。
                混合操作(Blend)： Off|Operations
                    BlendOP:Add|Sub|RevSub|Min|Max|...DX11.1 only
                    BlendFactors:One|Zero|SrcColor|SrcAlpha|DstColor|DstAlpha|OneMinuseSrcColor|OneMinuseSrcAlpha|OneMinuseDstColor|OneMinuseDstAlpha

Note:上面的测试顺序并不是唯一的。
    对于大多数GPU来说，会尽可能在执行片元着色器之前就进行这些测试（避免计算出颜色后，缺没有通过各种测试）。(先测试？后颜色？)
*Early-Z*技术：
    深度测试在片元着色之前进行。（GPU尽早的知道哪些片元会舍弃，这些片元就不再需要使用片元着色器计算颜色）
    Unity3d中使用了此技术。
        但是，如果将这些测试提前的话，其检验结果可能会与片元着色器中的一些操作冲突。例如，在片元着色器中进行了透明度测试(在着色器中调用了API，比如clip函数)来手动
        将其舍弃掉。这会导致GPU无法提前执行各种测试。
        因此，现在的GPU会判断片元着色器中的操作是否和提前测试发生冲突,如果有冲突，就会禁用提前而是。但是这样也会造成性能上的下降,因为有更多的片元需要被处理了。
        这也是透明度测试会导致性能下降的原因(无法使用Early测试)。
*双缓冲*(*Double Buffering*)策略：
    当模型的图元经过了上面层层计算和测试后，就会显示到屏幕上。屏幕上显示的就是颜色缓冲区中的颜色值。
    为了避免我们看到那些正在进行光栅化的图元，GPU会使用双缓冲策略。
    即，对场景渲染是发生在幕后的，即，在后置缓冲区(Back Buffer)中。一旦场景已经被渲染到了后置缓冲区中，GPU就会交换后置缓冲区和前置缓冲区（Front Buffer）中的内容，
    而前置缓冲区是之前显示在屏幕上的图形。
    由此保证我们看到图像总是连续的。
------------------------->page 18
2.GPU和图形编程接口
    如果开发者直接访问GPU，可能需要和各种寄存器、显存打交道。而图形编程接口在这些硬件的基础上实现了一层抽象。
    OpenGL和DirectX就是这些图形应用编程接口，用于渲染二维或三维。
    一个应用程序向图形应用编程接口发送渲染命令，接口会一次想*显卡驱动*(*Graphics Driver*)发送渲染命令。
    显卡驱动真正和GPU通信,同时也负责把纹理等数据转换成GPU所支持的格式。
    
                    
               CPU <------------------------------------------------------>    主存 
                |                                                               |
                ↓                                                               |
            应用程序                                                            |
    发送渲染命令|                                                               |
                ↓                                                               |
          OpenGL/DirectX                                                        |  顶点数据、纹理数据、着色器参数等
                |                                                               |
                ↓                                                               |
            显卡驱动                                                            |
                |                                                               |
                |                                                               |
    翻译命令    |                                                               |
                |                                                               |
                |                                                               |
        --------|---------------------------------------------------------------|------------------------
        |       |                                                               ↓                       |
        |  显卡 |                                            ------------------------------------------ |
        |       |                                            |                    显存                | |
        |       ↓                                            |                                        | |
        |      GPU <---------------------------------------->| 图形缓存    深度缓存    纹理   顶点缓存| |
        |                                                    |                                        | |
        |                                                    ------------------------------------------ |
        |                                                                                               |
        -------------------------------------------------------------------------------------------------
                                                  
                                                  



<<Unity Shaders and Effects Cookbook>>                                                           
note:很好的书。不是按照基础→应用的方式讲过的。按照应用→原理方式讲述。讲解了创建着色器和后期特效模板测试结束。与应用结合紧密。
        
