1.*Shader Reference*
    *surface sharders*
    *vertex and fragment shaders*
    *fixed function shaders*
    裁剪：(?裁剪指的是哪个？此三个地方，都有书中说裁剪)
        Clipping
        Culling
        Scissor
    note:不同的参考资料中给出的流水线名、顺序可能不相同，一个原因是由于图像编程接口（eg.OpenGL和DirectX）的实现不同，
        另一个原因是GPU在底层可能做了很多优化（eg.Early-Z 提前深度测试）。
2.流程图
    1.shaderlab 

    Transform,TexGen,Lighting                   (Early-Z技术)       Texturing Fog
                                ------>  Culling DepthTest  ----->                  ----->  Alpha Test ------> Blending
    Vertex Shader                                                   Fragment Shader 

    2.图形硬件流水线

                顶点连接信息
            -------------------------
                                    |                           (Colored Fragments)
                                    ↓         片段                   着色片段
        ---> 顶点变换   --->   图元装配和光栅化 ---> 片段纹理映射和着色 ---> *光栅化操作* --->
         顶点         被变换的顶点  |                                           ↑           更新像素
      (Vertices)                    ↓                                           |
                                    ---------------------------------------------

    3.光栅化操作

                                                    (Scissor Test)    (Alpha Test)   (Stencil Test)    (Depth Test)          (Blending)  (Dithering)    (Logic Op)        (Color Buffer)
        片段和与之相关联的数据  --→ 像素所有权测试  --→ 裁剪测试    --→ alpha测试   --→ 模板测试    --→   深度测试   --------→ 混合   --→ 抖动显示    --→ 逻辑操作    --→ 颜色缓冲区
                                                                                          |                |   |                 ↑                                               |
                                                                                          |      模板      |   |                 |                                               |
                                                                                          ---→  缓冲区  ←---   --→深度缓冲区      -------------------------------------------------
                                                                                            (Stencil Buffer)   (Depth Buffer)
    4.可编程图形流水线(The Programmable Graphics Pipeline)

                  3D应用程序或游戏
                        |
            3D API      |
           Commands     |
                        ↓
                    3D API:
                OpenGL或Direct3D
                        |                                       CPU-GPU Boundary
        ================|==============================================================================================================================================================================
                        |
           GPU Command  |                                                           Assembled Polygons
          & DataStream  |               Vertex Index Stream                             ,Lines&Points                                   Pixel Location Stream                Pixel Updates
                        |                  (顶点索引流)                           (装配后的多边形、线段和点)                                (像素位置流)                       (像素更新)
                        ↓
                 GPU Front End  ------------------------→ Pirmitive Assembly --------------------------------→ Resterization&Interpolation -----------------→ Raster Operations ---------→ Frame Buffer
                 (GPU 前端)                                 (图元装配)                                             (光栅化和插值)                              (光栅化操作)                 (帧缓冲)
                       |                                        ↑                                                         |                                         ↑
    Pretransformed     |                                        |   Transformed                Rasterized Pretransformed  |                                         | Transformed Fragments
      Vertices         |                                        |     Vertices                      Fragments             |                                         |    (变化后的片段)
    (变换前的顶点)     |                                        |  (变换后的顶点)                (光栅化的变化前的片段)   |                                         |
                       |                                        |                                                         |                                         |
                       -----→ Programmable Vertex Processor -----                                                         ------→ Programmable Fragment Processor ---
                                (可编程顶点处理器)
3.固定管线和可编程流水管线
<<Cg教程>>                                
note:有一些地方不是很明白。（眼空间那块。。。）
1.图形硬件流水线
    一个流水线是一序列可以并行和按照固定顺序进行的阶段。
    每个阶段都从它的前一阶段接收输入，然后把输出发给随后的阶段。

            顶点连接信息
        -------------------------
                                |
                                ↓         片段                   着色片段
    ---> 顶点变换   --->   图元装配和光栅化 ---> 片段纹理映射和着色 ---> 光栅化操作 --->
     顶点         被变换的顶点  |                                           ↑
                                ↓                                           |
                                ---------------------------------------------
    顶点(vertex)信息:
        位置                                position
        颜色                                color
        第二(反射)颜色  
        纹理坐标集(一个或多个)
        法向量                              normal
    1.顶点变换
        模型顶点位置变化到屏幕位置（以便光栅器使用）
        为贴图产生纹理坐标
        照亮顶点以决定顶点的颜色(?和光照有关)
    2.图元装配和光栅化
        图元装配阶段：
            将顶点装配为几何图元:根据伴随顶点序列的几何图元分类信息把顶点装配成几何图元
            输入：
                顶点序列
            过程：
                图元装配: 产生一序列的 三角形、线段和点
                    几何图元的类型：
                        点,独立的线段,循环线段,线段带
                        独立的三角形,三角带，三角扇
                        独立的四边形，四边形带，多边形
                裁剪:经过裁剪到可是*平截体*和任何有效的应用程序制定的*裁剪平面*
                culling(挑选):*光栅器*根据多边形的朝前或朝后来丢弃一些多边形。
            输出：
                多边形

        光栅化：
            决定哪些像素被几何图元覆盖的过程。
            多边形、线段和点根据每种图元指定的规则分别被光栅化。
            光栅化的结果是像素位置的集合和片段的集合
            输入：
                经过裁剪和culling的多边形
            过程：
                光栅化测试
            输出：
                像素位置的集合和片段的集合
            光栅化后，一个图元拥有的顶点数目和产生的片段之间没有任何关系。(顶点数和到了屏幕上的片段，没有关系)
        像素：图像元素的简称。代表帧缓存这种某个指定位置的内容。（eg.颜色，深度和其他与之歌位置相关联的值）
        片段(Fragment):一个片段是更新一个特定像素前在需要的一个状态.
            像素位置、深度值、
            经过插值的参数:颜色、第二（反射）颜色，一个或多个纹理坐标集
    3.插值、贴图和着色
       一个图元被光栅化成为片段的时候，如果片段属性需要，才进行插值、贴图和着色阶段.
       除了确定片段的最终颜色，这个阶段还新确定一个深度，或者甚至丢弃这个片段以避免更新帧缓存对应的像素。
       允许这个阶段可能丢弃片段，这个阶段为它接收到的每个输入片段产生一个或不产生着色过的片段。
       1.为片段：插值、着色（颜色）、产生深度
       2.丢弃片段
    4.光栅操作
        在最后更新帧缓存之前。执行最后一系列的针对每个片段的操作。
        此阶段：
            深度测试：消除隐藏面
            混合(blend):
            模板(stencil)：
            阴影:
        光栅操作阶段将根据许多测试来检测每个片段：
            裁剪：
            alpha:
            模板：
            深度测试：
        如果任意一项测试失败了，片段就会在这个阶段被丢弃,而更新像素的颜色纸（虽然一个模板写入的操作也许会发生）。
        通过了深度测试，就可以用片段的深度值代替像素的深度值了。
        在测试之后，混合操作将把片段的最后颜色和对应的像素的颜色结合在一起。


        片段和与之相关联的数据  --→ 像素所有权测试  --→ 裁剪测试    --→ alpha测试   --→ 模板测试    --→ 深度测试    --------→ 混合    --→ 抖动显示    --→ 逻辑操作    --→ 颜色缓冲区
                                                                                          |                |  |                 ↑                                               |
                                                                                          |      模板      |  |                 |                                               |
                                                                                          ---→  缓冲区  ←---  --深度缓冲区      -------------------------------------------------
2.可编程图形流水线(The Programmable Graphics Pipeline)
                  3D应用程序或游戏
                        |
            3D API      |
           Commands     |
                        ↓
                    3D API:
                OpenGL或Direct3D
                        |                                       CPU-GPU Boundary
        ================|==============================================================================================================================================================================
                        |
           GPU Command  |                                                           Assembled Polygons
          & DataStream  |               Vertex Index Stream                             ,Lines&Points                                   Pixel Location Stream                Pixel Updates
                        |                  (顶点索引流)                           (装配后的多边形、线段和点)                                (像素位置流)                       (像素更新)
                        ↓
                 GPU Front End  ------------------------→ Pirmitive Assembly --------------------------------→ Resterization&Interpolation -----------------→ Raster Operations ---------→ Frame Buffer
                 (GPU 前端)                                 (图元装配)                                             (光栅化和插值)                              (光栅化操作)                 (帧缓冲)
                       |                                        ↑                                                         |                                         ↑
    Pretransformed     |                                        |   Transformed                Rasterized Pretransformed  |                                         | Transformed Fragments
      Vertices         |                                        |     Vertices                      Fragments             |                                         |    (变化后的片段)
    (变换前的顶点)     |                                        |  (变换后的顶点)                (光栅化的变化前的片段)   |                                         |
                       |                                        |                                                         |                                         |
                       -----→ Programmable Vertex Processor -----                                                         ------→ Programmable Fragment Processor ---
                                (可编程顶点处理器)
3.光照和光照模型
    .光照和一个物体的材质特性一起决定了物体的外观
    .光照模型根据光和物体的特征，描述了光和物体之间的相互作用和影响
    .基本的光照模型：
                      光照      放射光  (Emissive) (自发光)
        物体表面颜色 ------→ {  环境反射(Ambient)
                      材质      漫反射  (Diffuse)
                                镜面反射(Specular)
        SurfaceColor=Emission + Ambient + Diffuse + Specular
        1.放射光 Emissive
            由物体表面发出的光，不影响其他物体
            模拟炽热物体
            计算完其他所有光照后，添加此颜色
            Emissive=Ke (Ke为材质的放射光颜色)
        2.环境反射 Ambient
            不依赖与光源的位置，来自四面八方
            受全局环境光的影响
            SurfaceColor的Ambient项依赖于材质的反射能力和环境光的颜色
            Ambient=Ka*GlobalAmbient    (Ka为材质环境光反射系数，GlobalAmbient为入射环境光的颜色)
        3.漫反射 Diffuse
            Diffuse=Kd*lightColor*max(N·L,0)
            Kd:材质的漫反射颜色
            lightColor:入射漫反射光的颜色
            N:单位表面法向量
            L:单位指向光源的向量
            P:被着色的点
        4.镜面反射 Specular
            依赖于观察者的位置，得能接收到反射光线
            受光源、材质的镜面反射性质和表面光泽度的影响
            （越由光泽的材质高光区越小，较少光泽的材质高光区越分散的开）
            Specular=Ks*lightColor*facing*pow((max(N·H),0),shininess)
            Ks:材质的镜面反射颜色
            lightColor:入射镜面反射光的颜色
            N:单位表面法向量
            V:视点的单位向量
            L:光源方向的单位向量
            H:V和L的中间向量的单位向量  H=(V+L)*0.5
            P:要着色的点
            facing:若N·H>0，则为1；否则为0
                （朝向。是否与Normal朝向相同，同方向才有作用。也就是漫反射光是否大于0，没有漫反射，自然也就没有镜面反射）
    .对光照模型的简化：
        所有光源共用一个全局环境颜色
        漫反射光和镜面反射光使用同一个颜色
        没有引入衰减或聚光灯效果
4.扩展光照模型
    1.距离衰减
        AttenuationFactor=1/(Kc+Kld+Kqd²)
        d：到光源的距离
        Kc,Kl,kq:控制衰减的常量
        常数项，一次系数，二次系数
        模拟真实世界中，一个点光源的强度以1/(d²)衰减，更多参数，更多控制
        衰减因子用于调整漫反射和镜面反射项
        lighting=Emission+Ambient+AttenuationFactor*(Diffuse+Specular)
    2.聚光灯效果
        (p123)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<<Untiy3d ShaderLab>>
note:豆瓣评这本书挺烂的，我也这么认为。很多内容都不符合标题要说的东西。概念也不说,或者有的说的也有问题。在没有弄清楚之前，还是不看这个了。
1.Shader结构
    Shader，定义文件名

    Shader "ShaderName"
    {
        Properties
        {
        }
        SubShader
        {
            Tags { "Queue"="Geometry" "RenderType"="Opaque" "IgnoreProjector"="True"}
            Pass
            {
                Name "PASS_NAME"  //可以被其他Shader引用,必须大写
                //eg.
                //UsePass "ShaderName/PASS_NAME"
            }
            Pass{}
            ...
        }
        SubShader
        {
        }
        ...
        FallBack "Default Shader Name"
    }
    1.SubShader用于编写不同显卡的处理 
        SubShader包装了一个渲染方案，而这个渲染方案是由一个个Pass块执行的。
        如果只有一个Pass,可以省略，写在SubShader块中
    2.SubShader的重要标签 Tags{}块
        Queue:
            Background      1000
            Geometry        2000
            AlphaTest       2450
            Transparent     3000
            Overlay         4000
        RenderType:
            Opaque
            Transparent
            TransparentCutout
            Background
            Overlay
            在替代渲染（Placement)做Post Effects时很重要，Unity内置的Image Effects根据它来决定如何替代渲染
            此外，如果相得到场景的一张ZDepth和Normals的快照，也需要一个正确的RenderType
        IgnoreProjector:
            True       当前物体忽略Projector的影响
            False

        自定义标签：
            eg. "MyTag"="Lucifer" 一般在替代渲染时用到（用于区分类别）
    3.SubShader中的 Pass{}块
        Pass中包含了渲染一个集合体的具体代码
        Pass块中的标签都是针对*渲染路径*的，告诉渲染引擎这个Pass在什么渲染路径下被渲染。
        Name 用于定义Pass的名字，以便别的shader可以引用，必须大写
        UsePass 用于引用Pass,路径为 shaderName/PASS_NAME
    4.FallBack保证Shader的广泛适用性
        如果用户所有的SubShader都失败了，为了在用户计算机上呈现设置的机制，使用FallBack指定所用的Shader。
2.ShaderLab支持的语言
    1.使用GLSL写Shader逻辑
        代码必须位于GLSLPROGRAM和ENDGLSH关键字之间
    2.使用Cg/HLSL
        代码必须位于CGPROGRAM和ENDCG关键字之间
3.Unity3d中Shader的3中形态
    1.固定管线 (Fixed Pipeline)
        应对老一代GPU，没有可编程流水管线的情况下使用。
        固定管线的形态和语法和NVIDIA的CgFX以及微软的FX文件比较类似。
        固定管线的相关代码都必须处于一个Pass块中。
    2.可编程Shader
        在Pass块中，编写顶点和片段程序
        Pass
        {
            CGPROGRAM
            #pragma vertex vert     //声明vertext Shader的函数为 vert
            #pragma fragment frag   //声明fragment Shader的函数为 frag
            #include "UnityCG.cginc"    //引用外部文件
            ...vert(...){}
            ...frag(...){}
            ENDCG
        }
        除此之外，还可以使用一些指令告诉Unity如何具体地编译Shader:
        1.#pragma target 2.0 
        :编译目标2.0，相当于Direct3D的Shader Model 2.0
        :对应与OpenGL下的
            256条ARB_vertex_shader的指令，
            32条ARB_fragment_shader的texture指令和
            64条普通指令，
            16个寄存器和
            4个贴图

        2.#pragma target 3.0  
        :编译目标3.0，相当于Direct3D的Shader Model 3.0
        :对应与OpenGL下的
            ARB_vertex_shader没有指令书目限制
            512条ARB_fragment_shader的texture指令和
            512条普通指令，
            32个寄存器和
            4个贴图
        3.对于面向OpenGL接口的情况，还可以使用
                #pragma profileoption MaxTexIndirection=256
            这样的指令。
            当编译平台为独立的可执行桌面OpenGL程序时，可以使用
                #pragma glsl
            把Cg代码转换为GLSL代码，从而绕过在Shader Model 3.0中的一些指令限制
        4.使用#pragma fragmentoption option来限制编译出的fragment函数
        5.#pragma glsl_no_auto_normalization
            对于移动平台GLSL,例如Android和IOS,用此来关闭vertex函数中对法线和且想了的自动单位化处理
        6.限制编译平台
            #pragma only_renderersd3d9 gles
            #pragma exclude_renderers xbox360
            适应于这两条指定的值有：d3d9,d3dll,opengl,gles(移动平台的OpenGL),xbox360,p3(任天堂的PlayStation),flash
    3.Surface Shader
        Unity通过Surface Shader把一些复杂性包装了起来，包括：
        处理不同的照明、点光源、平行光、光照贴图等
        处理不同的阴影选项
        在Unity的两个渲染路径(Forward和Deferred)下正常工作

        1.Surface Shader结构:
            最终会编译为一个复杂的vertex+fragment Shader.
            写在Pass块中（如果只有一个Pass,可以省略，写在SubShader块中）

            CGPROGRAM
            #pragma surface surf Lambert    //表面函数为surf,使用光照模型为Lambert
            ...
            void surf (Input IN, inout SurfaceOutput o){}
            ENDCG

            其中SurfaceOutput：
            struct SurfaceOutput
            {
                half3 Albedo;       //颜色纹理
                half3 Normal;       //法线
                half3 Emission;     //自发光，不受照明的影响
                half Specular;      //高光指数
                half Gloss;         //光泽度
                half Alpha;         //透明度,Alpha 通道
            }
4.Shader的数据接口 属性和uniform变量
    1.定义属性值
        Properties
        {
            _MyTexture ("Texture (RGB)", 2D) = "white" {}       //texture property
            _MyColor ("Color of Object", Color) = (1,1,1,1)     // color property
            _MyCube ("Environment map", Cube ) = "white"{}      //3d texture property(cube map),need 6 textures
            _MyVector ("Vector", vector) = (1,1,1,1)            //vector property
            _MyFloat ("Float Value", float) = 1.0               //float property
            _MyRange ("Another type of float", range(-10,10))=1.0   //float property with range
        }

        _VarName("inspector show name", varType) = default value
    2.在脚本中操控Material属性
        Material的方法中有获取和设置属性的接口
        public Material mat;

        mat.SetXXX("property Name",value)
        mat.GetXXX("property Name")

        Set/GetTexture
        Set/GetColor
        Set/GetTexture
        Set/GetFloat
    3.矩阵
    不能在属性块中定义
    可以在Shader中对一个矩阵进行声明，Material中有Get/SetMatrix的接口
    uniformfloat4x4 myMatrix;

    mat.SetMatrix("myMatrix",matrix);
    mat.GetMatrix("myMatrix");

    4.在Cg代码中使用属性
        在Cg代码中声明：
        CgVarType _VarName;     //varType _VarName

        CgVarType       varType;
        sampler2d       2D
        samplerCUBE     Cube
        float4          Color
        float4          vector
        float           float
        float           range(n,m)

        此外，数据类型中有：
        float       float4      32位
        half        half4       16位
        fixed       fixed4      8位
5.空间概念
    ref:OpenGL
        计算机图形的要点是，创建三维物体的二维图像。
        尽量在三维空间中想象物体的形状。
        为把一个物体的三维坐标变换为屏幕上的像素坐标,需要以下3个步骤：
        1.变换。
            包括模型、视图和投影操作。它们是由矩阵乘法表示的，这些操作包括旋转、移动、缩放、反射、正投影和头饰投影。
            一般情况下，在绘制场景时，需要组合使用几种变换。
        2.裁剪。
            由于场景时在一个矩形窗口中渲染的，因此位于窗口之外的物体（或物体的一部分）必须裁剪掉。
            在三维计算机图形中，裁剪就是丢弃位于裁剪平面之外的物体。
        3.视口变换
            最后，经过了变换的坐标和屏幕像素之间必须建立对应关系。这个过程称为视口变换。
            把三维的模型坐标转换为屏幕坐标
        
    1.*模型空间*(Model Space)
        模型物体都有一个以它自己的Pivot为原点的三维坐标空间。
        相对于模型自己的Pivot为原点的空间，叫做模型空间。
        模型空间在处理物体自身的一些相对关系时比较有用，eg.自身的面、线、点等。

        从*世界空间*到*模型空间*的转换：
        脚本中：
        transform.woldToLocalMatrix     //transform的世界空间到模型空间的转换矩阵
        transform.worldToLocalMatrix.MultiplyPoint(Vector3 v);      //将v点转化到transform的模型空间的位置
        transform.worldToLocalMatrix.MultiplyVector(Vector3 v);     //将v方向向量转到transform的模型空间向量
        Shader中：
        左乘_World2Object矩阵
    2.*世界空间*
        3D
        以世界坐标空间作为统一表达。
        当有多个物体的时候，所有物体使用世界空间坐标系来表达相对关系、位置、大小、旋转。

        从*模型空间*到*世界空间*的转换:
        脚本中：
        transtorm物体自身以模型空间坐标表达式的矢量变换到实践坐标表达式的矩阵和方法
        transform.localToWorldMatrix     
        transform.localToWorldMatrix.MultiplyPoint(Vector3 v);      
        transform.localToWorldMatrix.MultiplyVector(Vector3 v);     
        Shader中：
        左乘_Object2World矩阵
    3.*视空间*
        3D
        视空间又称为相机空间，为了方便表达以*相机为参考中心*时所有物体的相互关系的一个空间。

        从*世界空间*变换到*视空间*：
        脚本：
        通过Camera组件的worldToCameraMatrix,将一个世界坐标向量变换为以此相机为中心的空间表达式
        Camera.cameraToWoldMatrix，将以此相机空间的坐标系转换到世界坐标系
        Shader:
        使用矩阵UNITY_MATRIX_MV将向量从*模型空间*转到*视空间*
        MV:Model to View
    4.*视锥体*
        3D
        视锥体是看得到的部分。也即存在于相机的视锥体中,即存在于镜头中。
        只有处于视锥体内的物体才会被渲染，也就是在屏幕上能看到的东西。
        视锥体是由远近裁剪屏幕以及视角大小所顶一个的一个平头锥体，而相机处于锥体的顶点上。
        这个剔除掉视锥体以外的物体的过程，叫做Culling.
    5.*剪切空间*
        3d-->2d
        从视锥体（视线平截体，代表了眼空间中物体的可见区域），到2D屏幕上的坐标变换。
        这个过程的变换叫做*投影变换*
        (将3d物体投影到2d屏幕上？）
        从视锥体的三维空间，到二维平面上，需要首先进行一次*投影*,把视锥体变为一个长方体。
        这次变化是vertex Shader任务的重点。之后的引擎会自动处理下面的事情，把坐标转到NDC(Normalized Device Coordinates).
        这是一个无量纲的空间，OpenGL和Direct3D稍有不同:
        OpenGL 值域 （-1，-1，-1）到 （1,1,1）
        Direct3D值域 （-1,0，-1）到（1,1,1，）
        变换：
        脚本：
        (?从世界空间，到相机的投影空间的投射矩阵？？)
        此投影操作是Camera组件的projectionMatrix
        Shader:
        从模型空间投影到屏幕上
        UNITY_MATRIX_MVP
        MVP: Model View Projection
6.基本的光照模型
    1.光源对物体照明的分类
        间接照明:
        光在物体间传播后，最终又对物体形成的照明。
        eg.通过光线跟踪，光线多次反弹对物体进行照明。
        一般光线用烘焙lightmap和lightprob的方式进行，不做实时计算。
        直接照明：
        不考虑光线在物体间的传播，也不考虑光线在物体内部传播，光线对物体直接照明
            分为两种：
            .漫反射
            .镜面反射
                形成强烈高光
        直接照明是实时渲染的计算重点。
    2.Unity中的光照模型
        1.漫反射和Lambert
            .漫反射
                对于粗糙物体表面的某一点，其亮度应该和入射光线与该点的垂直程度相关，也就是入射光线与此法线的夹角相关。
                如果，用L代表单位长度的入射光线，C代表达到此点的光线的强度和颜色，N代表此点的法线，则物体表面此点的亮度Lum表示为:
                Lum=C*max(0,cos<L,N>)
                   =C*max(0,L·N)
                <L,N>表示矢量L和N之间的夹角。
                实际计算L·N可以用Cg标准库函数 dot(L,N)计算。
                使用max(0,value)来控制，如果是背光，最终结果不能为负值。
            .Lambert
                没有高光,适合制作橡胶类的东西
            可以把按照这种方式对物体进行照明计算的模型叫做*Lambert*
            Surface Shader中有两个内置的Lighting Model函数:
            LightLambert()                      Forward渲染路径下的Lambert光照方式
            LightingLambert_PrePass()           Deferred渲染路径下的Lambert光照方式
            位于Editor/Data/CGIncludes/Lighting.cginc文件中,函数如下：
            inline fixed4 LightLambert (SurfaceOutput s,fixed3 lightDir,fixed atten)
            {
                fixed diff=max(0,dot(s.Normal,lightDir));   //对漫反射的计算
                fixed4 c;
                //计算物体表面的纹理颜色、光源颜色以及光源强度的影响
                c.rgb=s.Albedo * _lightColor0.rgb * (diff * atten *2);
                c.a=s.Alpha;
                return c;
            }
            note:Unity5.x此函数发生了变换，可以添加多个光照的漫反射光
        2.镜面高光和Phong
            .镜面高光
                某一光线ray在某一法线为normal的点，反射后的光线，使用Cg标准库中的reflect(ray,normal)进行计算
                如果用R表示光线在此点的单位长反射方向向量，V表示视线的单位方向向量，gloss表示表面的镜面光滑程度，
                那么高光Spec计算方式为:
                Spec=pow(max(0,cos<V,N),gloss)
                    =pow(max(0,dot(V,N),gloss)
            .Phong
                有高光
                ref 百度：
                Phong光照模型分为三个累加阶段：漫反射，镜面反射和环境光
            Lambert的漫反射加上镜面高光，就是Phong
                c.rgb=s.Albedo * _lightColor0.rgb * ((diff+Spec) * atten *2);
            note:这个书里面说的不完全正确,需要参考其他书籍
        3.半角向量和BlinnPhong
            在上面高光计算的方式中，计算了一次入射光线的反射，然后考察此反射光线进入视野的程度。
            另外一种更简单、更易于调节的方式是，使用入射光线和视线的中间平均值，即*半角向量*，然后使用此半角向量和法线计算出一个和视角相关的高光。
            此种高光计算方式为*BlinnPhong*
            Surface Shader中有两个内置的Lighting Model函数:
            LightingBlinnPhong()                    Forward渲染路径下的BlinnPhong光照方式
            LightingBlinnPhong_PrePass()            Deferred渲染路径下的BlinnPhong光照方式
            位于Editor/Data/CGIncludes/Lighting.cginc文件中,函数如下：
            inline fixed4 LightingBlinnPhong (SurfaceOutput s,fixed3 lightDir,half3 viewDir,fixed atten)
            {
                half3 h=normalize(lightDir+viewDir);
                fixed diff=max(0,dot(s.Normal,lightDir));
                float nh=max(0,dot(s.Normal,h));
                float spec=pow(nh,s.Specular*128.0) * s.Gloss);

                fixed4 c;
                c.rgb=(s.Albedo*_LightColor0.rgb*diff+_LightColor0.rgb*_SpecColor.rgb*spec)*(atten*2);
                c.a=s.Alpha+_LightColor0.a*_SpecColor.a*spec*atten;
                return c;
            }
7.Unity中的照明
    1.渲染路径和Pass的LightMode标签
        Unity支持3种*RenderingPath*(*渲染路径*),分别为VertexLit,Forward和Deferred Lighting.
        为此，在Pass中使用的*LightMode*标签Vertex,ForwardBase,ForwardAdd,PrepassBase,PrepassFinal等，分别表示当前Pass是在哪个RenderingPath下设计使用。
    2.设计可以检测渲染路径的材质

<<Shader 入门精要>>
note:知乎推荐，初步看了下，很好的书.从基础讲起，建立读者对渲染流程的基本认识。
源码地址：https://github.com/candycat1992/Unity_Shaders_Book
.基础部分
1.渲染流水线
    三维场景--→二维纹理。
    1.渲染流程的3个阶段：
        .应用阶段（Application Stage)
        .几何阶段（Geometry Stage）
        .光栅化阶段（Rasterizer Stage）
        每个阶段通常也是一个流水系统，即包含了自流水线阶段。

        应用阶段 ------------→ 几何阶段 --------------→ 光栅化阶段
            ↓                   ↑    ↓                      ↑
            ↓                   ↑    ↓                      ↑
            --→ 输出渲染图元 ----    -----→ 输出屏幕空间 ----
                                             的顶点信息
        .应用阶段
            CPU实现。开发者可以控制。
            输入：
                1.准备好场景数据。
                    eg.Camera位置，视锥体设置，场景中的模型，光源
                2.粗粒度剔除(culling)
                    把不可见物体剔除
                3.设置每个模型的渲染状态
                    渲染状态包括但不限于材质（漫反射颜色、高光反射颜色）、使用纹理、使用的Shader等。
            处理过程：
                1.把数据加载到显存中
                    网格和纹理从内存中，加载到显存(Video Random Access Memory,VRAM)中
                2.设置渲染状态
                    设置网络应该被怎样渲染。
                    eg.设置使用哪个着色器、光源属性、材质等。
                3.调用Draw Call
                    DrawCall,从CPU发起，将一次需要渲染的图元列表(?是Display List吗)发送到GPU进行渲染。
            输出：
                渲染所需的几何信息，即*渲染图元*(*rendering primitives*)
                渲染图元可以是点、线、三角面等。
        .几何阶段(GPU流水线)
            在GPU上进行。处理每个渲染图元，进行逐顶点、逐多边形的操作（？逐多边形操作？？感觉有问题）
            输入：
                渲染图元
            处理：
                顶点坐标变换到屏幕空间,再交给光栅器进行处理。
            输出:
               渲染图元在屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色信息。 
        .光栅化阶段(GPU流水线)
            在GPU上进行。
            光栅化的主要任务是决定每个渲染图元中的哪些像素应该被绘制在屏幕上。
            对上一个阶段得到的逐顶点数据进行插值，再进行片段处理。
            输入：
                上一阶段的(二维)顶点信息
            处理：
                1.逐顶点数据插值，得到片段
                2.光栅化操作(各种测试和混合什么的)
            输出：
                屏幕上的像素
    2.GPU流水线
        简易流程图：
            几何阶段
                   -------------------------------------------------------------------------------
                   |  (可编程控制)     (可编程控制)       (可编程控)     (可配置)  (GPU固定实现) |
                   |                      (可选)            (可选)                               |
        顶点数据 --|-> 顶点着色器 ---> 曲面细分着色器 ---> 几何着色器 ---> 裁剪 ---> 屏幕映射    |
                   |                                                                     |       |
                   |                                                                     |       |
                   ----------------------------------------------------------------------|--------
                                                                                         |
                        ------------------------------------------------------------------
                        |
        光栅化阶段 -----|---------------------------------------------------------
                   |    ↓                                                        |
                   | 三角形设置 ---> 三角形遍历 ---> 片元着色器 ---> 逐片元操作 -|-> 屏幕图像
                   |(GPU固定实现)   (GPU固定实现)   (可编程控制)     (可配置)    |
                   |                                   (可选)                    |
                   ---------------------------------------------------------------

        几何阶段：
        .顶点着色器(Vertex Shader)
            完全可编程。通常用于实现顶点的空间变换、顶点着色等功能。
            顶点输入来源于CPU,输入进来的每一个顶点都会调用一次顶点着色。
            顶点着色器不会创建顶点，也无法得到顶点与顶点的关系。
            主要完成：坐标变换和*逐顶点光照*。可以修改顶点的其他信息。
                坐标变换：
                    可以改变顶点在坐标，这在*顶点动画*中非常有用。可以通过改变顶点位置来模拟水面、布料。
                    必须完成的一工作，就是把*顶点坐标*从*模型空间*转换到*齐次裁剪空间*。所以，顶点着色其中一般都有以下代码，
                        o.pos=mul(UNTIY_MATRIX_MVP,v.position)
        .曲面细分着色(Tessellation Shader)
            可选。用于细分图元。
        .几何着色器(Geometry Shader)
            可选。被用于执行逐图元的着色操作，或被用于产生更多的图元。
        .裁剪(Clipping)
            可配置。将不在摄像机视野内的顶点裁剪掉，并剔除(culling)某些三角图元的面片。
            eg.自定义裁剪平面来配置裁剪区域；通过指令控制裁剪三角图元的正面还是背面（Cull Off|Front|Back）
            裁剪到视锥体内。
            一个图元和摄像机的视野关系有3中：完全在视野内、部分在视野内、完全不在视野内。
            完全在视野内：传递下去
            完全不在视野内：不传递下去
            部分在视野内：为图元和视野立方体框的交界处生成新的顶点,并且将在视野外的顶点去掉。这个过程就是裁剪（Clipping）.
        .屏幕映射(Screen Mapping)
            不可配置、不可编程
            把每个图元的x和y坐标(三维坐标)转换到屏幕坐标系（Screen Coordinates）(二维坐标)。与显示画面的分辨率有很大关系。
            把场景渲染到屏幕窗口中，屏幕窗口的最小坐标为（x₁,y₁）,大坐标为(x₂,y₂),其中x₁<x₂,y₁<y₂。
            场景经过上一步骤的裁剪,输入的坐标范围为（-1,1）,到屏幕上(范围与分辨率有关系)。因此，这是一个缩放的过程。
            输入的z坐标不会做任何处理。实际上，屏幕坐标系和z坐标一起构成了一个坐标系，叫做*窗口坐标系*（*Window Coordinates*）

                                                                        
                (1,1)                                                                  (x₂,y₂)    
                    -----------------                             -------------------------
                    |               |                             |                       |
                    |               |           屏幕映射          |                       | 
                    |               |     ----------------->      |                       | 
                    |               |                             |                       | 
                    -----------------                             |                       |
                                    (-1,-1)                       |                       |
                                                                  -------------------------
                                                               （x₁,y₁）

            note:OPenGL和DirectX的屏幕坐标系有差异。OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则把屏幕的左上角作为最小的窗口坐标值

                                                        (x,y)            (0,0)    
                                   -------------------------                  -------------------------
                                   |                       |                  |                       |
                                   |                       |                  |                       | 
                                   |                       |                  |                       | 
                                   |                       |                  |                       | 
                                   |                       |                  |                       |
                                   |                       |                  |                       |
                                   -------------------------                  -------------------------
                                （0,0）                                                          （x,y）
                                       OpenGL屏幕坐标                               DirectX屏幕坐标

            微软的窗口都使用了从左到右、从上到下的符合我们阅读习惯的方式。并且很多图像文件也是按照这种格式存储的。
        光栅化阶段：
            上一阶段的输出信息是顶点的屏幕坐标信息，以及其他的额外信息，如深度值（z坐标）、法线方向、视角方向等。
            光栅化阶段会计算每个图元覆盖了哪些像素，以及为这些像素计算颜色。
        .三角形设置(Triangle Setup)
            固定函数（Fixed-Function）阶段。
            计算光栅化一个三角网格所需要的信息。
            上一阶段输出的都是三角网格顶点(并没有三角形的边，只有顶点)。为了得到整个三角网格对屏幕像素的覆盖情况，需要计算每条边上的像素坐标。从顶点->三角形边界，叫做三角形设置。
        .三角形遍历(Triangle Traversal)
            固定函数（Fixed-Function）阶段。
            (插值生成片元的过程)
            此阶段会检查每个像素是否被一个三角网格所覆盖,并使用三角网格的3个顶点信息对整个覆盖区域的像素进行*插值*。如果覆盖了，就会生成一个*片元*（*fragment*）。
            这样一个找到哪些像素被三角网格覆盖的过程就是*三角形遍历*,也称为*扫描变换*（*Scan Conversion*）
            这一步骤的输出是一个片元序列。
        .片元着色器(Fragment Shader)
            完全可编程。用于实现逐片元的着色操作。
            在DirectX中，片元着色器被称为像*素着色器*（*Pixel Shader*）
            此步骤最终会输出为一个或多个颜色值。
            纹理采样在此步骤。纹理坐标也是插值得到的。
        .逐片元操作(Pre-Fragment Operations)
            可配置。负责执行很多重要的操作，eg.修改颜色、深度缓冲、进行混合
            （对应Cg教程中的光栅化操作Raster Operations）
            此步骤在OpenGL中叫做*逐片元操作*(*Pre-Fragment Operations*)，在DirectX中，叫做*输出合并阶段*（*Output-Merge*）
            主要任务：
                1.测试
                    决定每个片元的可见性
                    测试工作,eg.模板测试,深度测试
                2.混合(通过了测试的片元)
                    通过了测试的片元，就需要把这个片元的颜色和已经存储在颜色缓冲区中的颜色进行混合,最后再写入颜色缓冲区中。
                                                
                片元 ----> 模板测试 ---> 深度测试 ---> 混合 ---> 颜色缓冲区
           .测试和混合
                测试的过程比较复杂，并且不同的图形接口（OpenGL和DirectX）的实现细节不同。
                
                简化流程：

                                开始模板测试                                                  开始深度测试                            
                                     |                                                             |
                        否           ↓                                                否           ↓
                ----------- 是否开启了模板测试                                ----------- 是否开启了深度测试
                |                    |                                        |                    |
                |                    |  是                                    |                    |  是
                |                    ↓                                        |                    ↓
                |         比较参考值（使用读取掩码）                          |         比较该片元的深度值和已经
                |         和已经存在于模板缓冲区中的                          |         存在于深度缓冲区中的深度值
                |         模板值（使用读取掩码）                              |                    |
                |                    |                                        |                    |
                |                    ↓                                        |                    ↓
                |             得到模板测试结果                                |             得到深度测试结果
                |                    |                                        |                    |
                |                    ↓              否                        |                    ↓              否
                |             是否通过了模板测试 -----------                  |             是否通过了深度测试 ------------------
                |                    |                     |                  |                    |                            |                  
                |                    |  是            舍弃该片元              -------------------> |  是                        |
                |                    ↓                     |                                       ↓                         舍弃该片            
                |            根据状态设置更新              |                                   是否开启了     否                |            
                |            模板缓冲区中的值 <-------------                                    深度写入   -------------        |
                |            （使用掩码写入）                                                      |                   |        | 
                |                    |                                                             | 是                |        | 
                -------------------> |                                                             ↓                   |        | 
                                     ↓                                                         将深度值写              |        | 
                                模板测试结束                                                  入深度缓冲区             |        |
                                                                                                    |                  |        |
                                                                                                    | <-----------------        |
                                                                                                    ↓                           |
                                                                                              深度测试结束  <--------------------
                                
            1.模板测试（Stencil Test）
                *模板缓存区*（*Stencil Buffer*）
                如果开启了模板测试，GPU首先会读取(使用读取掩码)模板缓冲区中该片元位置的模板值,然后将该值和读取(使用读取掩码)到的*参考值*(*reference value*)进行比较,
                这个比较函数可以由开发者指定。
                Comp comparisonFunction(default is always)
                缓冲区模板值-参考值,满足条件的，通过测试。不满足条件的，舍弃该片元
                    Greater
                    GEqual
                    Less
                    LEqual
                    NotEqual
                    Always
                    Never
                无论是否通过了模板测试，都可以修改模板缓冲区，比如设置选项有，
                    Pass xxx          通过测试操作
                    Fail xxx          测试失败的操作
                    ZFail xxx         深度测试失败的操作(通过了模板测试，但是没有通过深度测试)
                    xxx表示Stencil Operation.
                    其中, Stencil Operation有:
                        Keep
                        Zero
                        Replace
                        IncrSat
                        DecrSat
                        Invert
                        IncrWrap
                        DecrWarp
                模板测试通常用于限制渲染区域。一些高级用法可以用于渲染阴影、轮廓渲染等。
            2.深度测试（*Depth Test*）
                *深度缓冲区*(*Depth Buffer*)
                片元通过了模板测试，会进入深度测试。
                如果开启了深度测试，GPU会把该片元的深度值和已经存在于*深度缓冲区*中的深度值进行比较。
                比较：片元深度值-深度缓冲区深度值,满足条件的通过测试。如果没有通过测试，就舍弃该片元。
                    ZTest xxx
                    Less
                    Greater
                    LEqual
                    GEqual
                    NotEqual
                    Always
                通常使用小于等于(LEqual),因为深度值小，距离摄像机距离近。
                如果通过了深度测试，并且开启了深度写入（ZWrite）,能覆盖深度缓冲区中的值。
                    ZWrite On|Off
                    note:透明效果和深度测试以及深度写入的关系非常密切。
            3.混合/合并（Blend）
                片元通过了上面的测试，会来到混合/合并阶段。
                *颜色缓冲区*（*Color Buffer*）
                每个像素的颜色信息都被存储在一个名为颜色缓冲的地方。最终屏幕上显示的颜色，也是从颜色缓冲中得到的。
                是否开启*混合*(Blend)，影响本次片元的渲染是否要覆盖颜色缓冲区。
                note:因此，半透明物体一定要开启混合呀
                混合操作流程图：
                                                开始混合
                                                   |
                                                   ↓            否
                                             是否开启了混合 -------------------------------
                                                   |                                      |
                              (Src)                | 是             (Dst)                 |
                            得到源颜色 <-----------|-----------> 得到目标颜色             |
                           (片元的颜色值)                      (已经存在于颜色缓          |
                                |                               冲区中的颜色值)           |
                                |                                    |                    |
                                |                                    |                    |
                                -----------> 进行混合操作 <-----------                    |
                                                  |                              直接使用该片元的颜色值
                                                  |                                       |
                                                  ↓                                       |
                                            更新颜色缓冲区 <-------------------------------
                                               中的值
                                                  |
                                                  ↓
                                              混合结束
                如果没有开启混合，片元的颜色会直接覆盖颜色缓冲区中的颜色，这也是初学者无法得到透明效果的原因。
                如果开启了混合，GPU会去除源颜色和目标颜色，进行混合。
                    源颜色：片元着色器得到的颜色值
                    目标颜色：已经存在于颜色缓冲区中的颜色值。
                混合操作(Blend)： Off|Operations
                    BlendOP:Add|Sub|RevSub|Min|Max|...DX11.1 only
                    BlendFactors:One|Zero|SrcColor|SrcAlpha|DstColor|DstAlpha|OneMinuseSrcColor|OneMinuseSrcAlpha|OneMinuseDstColor|OneMinuseDstAlpha

Note:上面的测试顺序并不是唯一的。
    对于大多数GPU来说，会尽可能在执行片元着色器之前就进行这些测试（避免计算出颜色后，缺没有通过各种测试）。(先测试？后颜色？)
*Early-Z*技术：
    深度测试在片元着色之前进行。（GPU尽早的知道哪些片元会舍弃，这些片元就不再需要使用片元着色器计算颜色）
    Unity3d中使用了此技术。
        但是，如果将这些测试提前的话，其检验结果可能会与片元着色器中的一些操作冲突。例如，在片元着色器中进行了透明度测试(在着色器中调用了API，比如clip函数)来手动
        将其舍弃掉。这会导致GPU无法提前执行各种测试。
        因此，现在的GPU会判断片元着色器中的操作是否和提前测试发生冲突,如果有冲突，就会禁用提前而是。但是这样也会造成性能上的下降,因为有更多的片元需要被处理了。
        这也是透明度测试会导致性能下降的原因(无法使用Early测试)。
*双缓冲*(*Double Buffering*)策略：
    当模型的图元经过了上面层层计算和测试后，就会显示到屏幕上。屏幕上显示的就是颜色缓冲区中的颜色值。
    为了避免我们看到那些正在进行光栅化的图元，GPU会使用双缓冲策略。
    即，对场景渲染是发生在幕后的，即，在后置缓冲区(Back Buffer)中。一旦场景已经被渲染到了后置缓冲区中，GPU就会交换后置缓冲区和前置缓冲区（Front Buffer）中的内容，
    而前置缓冲区是之前显示在屏幕上的图形。
    由此保证我们看到图像总是连续的。
2.GPU和图形编程接口
    如果开发者直接访问GPU，可能需要和各种寄存器、显存打交道。而图形编程接口在这些硬件的基础上实现了一层抽象。
    OpenGL和DirectX就是这些图形应用编程接口，用于渲染二维或三维。
    一个应用程序向图形应用编程接口发送渲染命令，接口会一次想*显卡驱动*(*Graphics Driver*)发送渲染命令。
    显卡驱动真正和GPU通信,同时也负责把纹理等数据转换成GPU所支持的格式。
    
                    
               CPU <------------------------------------------------------>    主存 
                |                                                               |
                ↓                                                               |
            应用程序                                                            |
    发送渲染命令|                                                               |
                ↓                                                               |
          OpenGL/DirectX                                                        |  顶点数据、纹理数据、着色器参数等
                |                                                               |
                ↓                                                               |
            显卡驱动                                                            |
                |                                                               |
                |                                                               |
    翻译命令    |                                                               |
                |                                                               |
                |                                                               |
        --------|---------------------------------------------------------------|------------------------
        |       |                                                               ↓                       |
        |  显卡 |                                            ------------------------------------------ |
        |       |                                            |                    显存                | |
        |       ↓                                            |                                        | |
        |      GPU <---------------------------------------->| 图形缓存    深度缓存    纹理   顶点缓存| |
        |                                                    |                                        | |
        |                                                    ------------------------------------------ |
        |                                                                                               |
        -------------------------------------------------------------------------------------------------
                                                  
3.其他
    1.HLSL/GLSL/CG之间的关系
                                                                    所属                                
        *HLSL*(High Level Shadering Language)                       DirectX                         
        *GLSL*(OpenGL Shadering Language)                           OpenGL                              
        *CG*(C for Graphic)                                         NVIDIA
        都是相对于着色汇编语言的高级语言。（类似于汇编和c语言之间的关系。只不过，这些语言是编写GPU的）
        .其他：
            GLSL的*优点*在于跨平台。
                OpenGL并没有提供编译器，而是由显卡驱动来完成着色编译工作。所以，只要有使用的显卡驱动，就可以使用OpenGL。
            HLSL是由微软控制着色器的编译。
                由于支持的平台有限，使用者几乎都是微软自己的产品：Windows，Xbox 360，PS3等。
            CG是真正意义上的跨平台
                它会根据不同的平台，编译成相应的中间语言。
                不过，CG的跨平台性取决于与微软合作，因此导致了CG语言和HLSL很像。
                CG语言可以无缝一直成HLSL。可能无法发挥出OpenGL的最新特性。
    2.Unity Shader中的语言
        可以使用"CG/HLSL"或者"GLSL"。但是都不是真正意义上的对应的语言。(做了封装和修改)
    3.命令缓冲区
        为了让CPU和GPU能够并行工作，解决方法是使用一个*命令缓冲区*（*Command Buffer*）
        CPU可以向命令缓冲区中添加命令，当GPU完成上一次渲染，GPU从命令缓冲区中再读取一条命令。
            
                                      命令缓冲区
                                    ----------------    读取命令
                                    |  命令i       | ---------->GPU 
                                    |  命令i+1     | 
                        添加命令    |  命令i+2     |
                  CPU ------------> |  命令i+3     |
                                    |              |
                                    |              |
                                    |--------------|
    4.DrawCall
        DrawCall是CPU放入命令缓冲区中的命令中的一种。一个DrawCall就是一次命令。
        每一次调用DrawCall，CPU要向GPU发送很多内容，包括数据、状态和命令等。
        这一阶段，CPU需要完成很多工作，例如检测渲染状态，准备数据等。GPU渲染的能力是很强。
        因此渲染速度往往取决于CPU提交命令的速度。
        如果DrawCall数量太多，CPU就会把大量时间花费在提交DrawCall上，造成CPU过载。
    5.固定渲染管线
        *固定函数的流水线*（*Fixed-Function Pipeline*）,也简称为固定管线，通常是指在较旧的GPU上实现的渲染流水线。这种流水线
        只给开发者提供一些配置操作，没有完全控制权。
    6.Shader是什么
        Shader是：
        .GPU流水线上一些可高度编程的阶段,由着色器编译出来的代码最终会在GPU上运行（对于固定管线的渲染来说，着色器有时等于一些特定的渲染设置）；
        .有一些特定类型的着色器，如果顶点着色器、片元着色器。
        .依靠着色器，我们可以控制流水线中的渲染细节。
--------------------->page 24
4.UnityShader基础
5.数学基础
    1.*笛卡尔坐标*(*Cartesian Cordinate System*)
        .组成:
            原点
            坐标轴:过原点，并且互相垂直的矢量
                坐标轴也被称为该坐标系的*基矢量*(*basis vector*)
                通常情况下，坐标轴是互相垂直的，并且长度为1。这样的基矢量被称为*标准正交基*(*orthonormal basis*)
                如果坐标轴是互相垂直的，但是长度不为1,这样的基矢量被称为*正交基*(*orthogonal basis*)
                *正交可以理解为互相垂直
        .*左手坐标系*(*left-handed coordinate space*)和*右手坐标系*(*right-handed coordinate space*)
            如果两个坐标系具有相同的*旋转性*(*handedness*),通过选择的方法可以让两个坐标轴指向重合。如果不具有旋转性，就不能通过旋转重合。
            使用拇指，食指和中指，让他们分别垂直，其中食指指向上方。
                拇指指向为x轴，食指指向为y轴，中指指向为z轴。
            两种坐标系想要重合，必须翻转其中一个坐标系的一个轴。
            .旋转正方向:
                左手坐标系的旋转正方向由左手法则定义
                右手坐标系的旋转正方向由右手法则定义
            .Unity使用的坐标系:
                对于模型空间和世界空间，Unity使用的是*左手坐标系*
                对于观察空间（以摄像机为原点的坐标系），使用的是*右手坐标系*。
                    观察空间，也就是人眼看到的空间。模型和世界都在人眼的对面，z轴是反向的.
                    摄像机在模型空间和世界空间也是左手坐标系，在摄像机视野中的物体，相对与摄像机的位置，摄像机前方的物体在摄像机的z轴
                    负方向。也就是所，模型在观察空间，z轴减少，意味着场景深度的增加。(z轴越小，距离摄像机越远，深度越大)
    2.*点*(*point*)和*矢量*(*vector*)
        .点是n维空间中的一个位置，没有大小和宽度
        .*矢量*(*vector*)，也被称为*向量*，有大小和方向。存在的意义是为了区别*标量*(*scalar*)
            矢量是指n维空间中一种包含了*模*(*magnitude*)和*方向*(*direction*)的有向线段。
            模指的是矢量的长度，方向描述了矢量在空间中的指向
            end->head  == (head-end) 
        .*单位矢量*(*unit vector*):模为1的矢量
        .*归一化矢量*(*normalized vector*):模为1的矢量。把非零矢量转换成单位矢量的过程被称为*归一化*(*normalization*)
        .*点积*(*dot product*),也叫*内积*(*inner product*)
            点积：a·b   ·不可省略
            满足交换律：a·b=b·a
            几何意义在于*投影*(*projection*)：a向量在b向量方向上的投影
            a·b=|a|*|b|cos(θ)
        .*叉积*(*cross product*),也叫*外积*(*outer product*)
            叉积：aXb=(ax,ay,az)X(bx,by,bz)=(aybz-azby,azbx-axbz,axby-aybx)
                                             (yz  zy)  (zx  xz)  (xy  yx)
                |axb|=|a||b|sin(θ)=平行四边形的面积
            叉积结果向量方向：左右手坐标系的选择不会影响叉积的结果
            用处：计算垂直于一个平面、三角形的矢量；判断三角面片的朝向。
    3.*矩阵*(*maxtrix*)
        三维数学中，我们通常使用矩阵来进行变化。
        .矩阵定义
            M矩阵由m*n个标量组成，表示有m行(row)，n列(column)
            eg.3X3矩阵
                     m₁₁ m₁₂ m₁₃
                M =[ m₂₁ m₂₂ m₂₃ ]
                     m₃₁ m₃₂ m₃₃
        .和矢量的联系
            矢量可以看成是nx1的*列矩阵*(*column matrix*)或1xn的*行矩阵*(*row matrix*),其中n对应了矢量的维度。
            eg. v=(3,8,6)
                行矩阵 ：[3 8 6]
            
                列矩阵：  3
                        [ 8 ]
                          6
            让矢量可向一个矩阵一样，一起参与矩阵运算，这在空间变换中非常有用。
        .矩阵运算
            1.矩阵和标量的乘法
                kM=Mk=k*(M中的每一个标量)
            2.矩阵和矩阵的乘法
                [Amxn][Bnxk]    A为m行n列，B为n行k列。A的列数量=B的行数量
                .不满足交换律
                    AB!=BA
                .满足乘法结合律
                    (AB)C=A(BC)
        .特殊的矩阵
            1.*方块矩阵*（*square matrix*）,简称*方阵*
                行数和列数相等的矩阵
                三维渲染中，最常使用的是3x3和4x4方阵
                .*对角元素*（*diagonal elements*）
                    方阵中的行号和列号相等的元素。eg. m₁₁,m₂₂,m₃₃
                .*对角矩阵*（*diagonal matrix*）
                    如果一个矩阵(方阵)除了对角元素外的所有元素都为0，那么这个矩阵就是对角矩阵。(肯定是方阵，因为方阵才有对角元素)
            2.*单位矩阵*（*identity matrix*）
                3x3的单位矩阵 
                        1   0   0
                    I₃= 0   1   0
                        0   0   1
                任何矩阵和单位矩阵相乘，结果还是原来的矩阵:
                    MI=IM=M
            3.*转置矩阵*（*transposed matrix*）
                对原矩阵进行了*转置运算*后，得到转置矩阵。
                对矩阵的行和列进行转置。MT(ij)=M(ji)
                .矩阵转置的转置等于原矩阵
                    (MT)T=M
                .矩阵串接的转置，等于反向串接各个矩阵的转置
                    (AB)T=(BT)(AT)
            4.*逆矩阵*(*Inverse matrix*)
                不是所有矩阵都有逆矩阵。
                .有逆矩阵的一个必要非充分条件是：该矩阵必须是一个方阵
                逆矩阵的定义：
                    一个矩阵和它的逆矩阵相乘，结果是一个单位矩阵
                        MM⁻¹=M⁻¹M=I
                如果一个矩阵有对应的逆矩阵，那么就说这个矩阵是*可逆的*(*invertible*),或者说，是*非奇异的*(*nonsingular*)
                (一个矩阵就是一个变化，可逆矩阵表示，这个变换是可逆的)
                相反，如果一个矩阵没有对应的逆矩阵，就说它是*不可逆的*(*noninvertible*)，或者说，是*奇异的*(*singular*)
                .如果一个矩阵的*行列式*(*determinant*)不为0，那么它就是可逆的。
                .逆矩阵的性质：
                    1.逆矩阵的逆矩阵是原矩阵
                        (M⁻¹)⁻¹=M
                    2.单位矩阵的逆矩阵是它本身
                        I⁻¹=I
                    3.转置矩阵的逆矩阵是逆矩阵的转置
                        (MT)⁻¹=(M⁻¹)T
                    4.矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵
                        (AB)⁻¹=A⁻¹B⁻¹
                        (ABCD)⁻¹=A⁻¹B⁻¹C⁻¹D⁻¹
                .逆矩阵的几何意义
                    一个矩阵可以表示一个变换，而逆矩阵允许我们还原这个变化，或者说计算这个变化的反向变换。
                    因此，如果我们使用变化矩阵M对矢量v进行了一次变化，然后再使用它的逆矩阵M⁻¹进行另一次变换，那么我们就会得到原来的矢量。
                        M⁻¹(Mv)=(M⁻¹M)v=Iv=v
            5.*正交矩阵*(*orthogonal matrix*)
                正交是一种属性。
                如果一个方阵M和它的转置矩阵的乘积是单位矩阵的话，我们就说这个矩阵是*正交*(*orthogonal*)的。
                    M(MT)=(MT)M=I
                结合逆矩阵的性质，得：
                如果一个矩阵是正交的，那么它的转置矩阵和逆矩阵是一样的，也就是说，矩阵M是正交的等价于：
                    MT=M⁻¹
                note:在三维变化中，我们经常会使用逆矩阵来求解反向的变换。而逆矩阵的求解往往计算量很大，但是转置矩阵却非常容易求解。
                所以，如果能够知道矩阵是正交矩阵的话，就可以很轻易的求出逆矩阵。
                判断一个矩阵是否正交，不通过就算，可以根据一个矩阵的构造过程来判断这个矩阵是否是正交的。
                    *如果组成矩阵的是一组标准正交基，那么它就是一个正交矩阵*
                推导：
                    一个3x3的正交矩阵M，根据定义，有：

                                -   c₁  -       |   |   |           c₁·c₁   c₁·c₂   c₁·c₃       1   0   0
                        (MT)M=  -   c₂  -   ·   c₁  c₂  c₂      =   c₂·c₁   c₂·c₂   c₂·c₃   =   0   1   0   =I(单位矩阵)    
                                -   c₃  -       |   |   |           c₃·c₁   c₃·c₂   c₃·c₃       0   0   1
                                
                                ==>
                                    c₁·c₁=1   c₁·c₂=0   c₁·c₃=0
                                    c₂·c₁=0   c₂·c₂=1   c₂·c₃=0
                                    c₃·c₁=0   c₃·c₂=0   c₃·c₃=1
                    可得：
                        .矩阵的每一行，即c₁,c₂,c₃都是单位矢量，因为只有这样它们与自己的点积才能是1
                        .矩阵的每一行，即c₁,c₂,c₃之间互相垂直，因为只有这样它们与自己的点积才能是0
                        .上述结论对矩阵的每一列同样适用（因为如果M是正交矩阵的话，MT也是正交矩阵）
                    因此，我们会使用坐标空间的*基矢量*来构建用于空间变换的矩阵。
                    如果这些基矢量是一组*标准正交基*的话（只存在旋转变换），那么就可以直接使用转置矩阵来求得该变换的逆变换。
                    (如果使用的是*正交基*(*基矢量*)来构建一个矩阵，这个矩阵可能不是一个正交矩阵，因为这些基矢量的长度可能不为1)
        .矢量和矩阵相乘
            矢量可以转成行矩阵或者列矩阵。矢量要和一个矩阵相乘：
                矢量的行矩阵v=(x  y   z)
                                x
                矢量的列矩阵v=[ y ]
                                z
                             m₁₁ m₁₂ m₁₃
                M矩阵   M =[ m₂₁ m₂₂ m₂₃ ]
                             m₃₁ m₃₂ m₃₃
                
                矢量的行矩阵乘以M矩阵(需要把v放在左边)：
                    vM=[xm₁₁+ym₂₁+zm₃₁  xm₁₂+ym₂₂+zm₃₂  xm₃₁+ym₃₂+zm₃₃]

                矢量的列矩阵乘以M矩阵(需要把v放在右边):
                        
                         xm₁₁+ym₁₂+zm₁₃
                    Mv=[ xm₂₁+ym₂₂+zm₂₃  ]
                         xm₃₁+ym₃₂+zm₃₃
                vM和Mv的结果出来行列不同之外，元素也不同。因此，在和矩阵相乘时，选择行矩阵还是列矩阵来表示矢量是非常重要的。
            在Unity中，常规做法是把*矢量放在矩阵的右侧*，即把*矢量转成列矩阵*来进行运算。之后的内容无特殊情况，都使用*列矩阵*。
            即，之后的矩阵乘法使用*右乘*：
                                    CBAv=(C(B(Av)))
                阅读顺序从右到左，即先对v进行A变换，再使用B进行变换，最后使用C进行变换。等价于：
                                    v(AT)(BT)(CT)=(((vAT)BT)CT)
    4.变换（矩阵的几何意义）
        三维渲染中的矩阵用于变换。因此，如果在后面的内容看到了一个矩阵，就是看到了一个变换。（线性代数中矩阵的用处不仅是用于变换，但是在笔记中仅用于此）
        变换一般包括了旋转、缩放和平移。给定一个点或者一个矢量，再给定一个变换，就可以通过某个数学运算来求得新的点和矢量。
        1.*变换*（*transform*）
            变换指的是，我们把一些数据，如点、方向矢量甚至是颜色等，通过某种方式进行转换的过程。
            .*线性变换*(*linear transform*):可以保留矢量加和标量乘的变换。满足以下两个条件：
                                        f(x)+f(y)=f(x+y)
                                        kf(x)=f(kx)
                *缩放*(*scale*)就是一种*线性变换*。eg.f(x)=2x，可以表示一个大小为2的统一缩放。
                *旋转*(*rotation*)也是一种*线性变换*。
            .*放射变换*(*affine transform*)
                对于线性变换来说，如果我们要对一个三维的矢量进行变换，那么仅仅使用3x3的矩阵就可以表示所有的线性变换。
                但是，如果要考虑到平移变换，eg.f(x)=x+(1,2,3),将x平移(1,2,3),就不是一个线性变换。
                *放射变换*就是合并线性变换和平移变换的变换类型。
                *放射变换*可以使用一个4x4的矩阵来表示。为此，也需要*把矢量扩展到四维空间*下。这就是*齐次坐标空间*(*homogeneous space*).

            图形学中常见的变换矩阵名称和他们的特效：

                    变换名称        是线性变换吗    是放射变换吗    是可逆矩阵吗    是正交矩阵吗
                    *平移矩阵*            N               Y               Y               N        
              绕坐标轴旋转的*旋转矩阵*    Y               Y               Y               Y
              绕任意轴旋转的*旋转矩阵*    Y               Y               Y               Y
              按坐标轴缩放的*缩放矩阵*    Y               Y               Y               N
                    *错切矩阵*            Y               Y               Y               N
                    *镜像矩阵*            Y               Y               Y               Y
                  *正交投影矩阵*          Y               Y               N               N
                  *透视投影矩阵*          N               N               N               N
                
        2.*齐次坐标*(*homogeneous coordinate*)
            由于3x3矩阵不能表示平移操作，因此扩展到4x4的矩阵（多一个维度就可以实现对平移的表示）。
            为此，把原来的三维矢量转换成*四维矢量*，也就是*齐次坐标*(*homogeneous coordinate*)
            (事实上齐次坐标的维度可以超过四维，但在本笔记中所说的齐次坐标将泛指四维齐次坐标)
            .把三维矢量转换成其次坐标：
                对于一个点，从三维坐标转换成齐次坐标是把其w分量设为1.(4x4矩阵对点进行平移、旋转、缩放都会施加于该点)
                对于方向矢量，把其w分量设为0.(4x4矩阵对点进行旋转、缩放会施加于该矢量，但是平移效果会忽略)
        3.分解基础变换矩阵
            4x4矩阵可以表示平移、旋转和缩放。把表示纯平移、纯旋转和纯缩放的变换矩阵叫做*基础变换矩阵*。
                --                 --
                |   M₃x₃    t₃x₁    |
                |   0₁x₃    1       |
                --                 --
            其中M₃x₃表示旋转和缩放，t₃x₁用于表示平移。0₁x₃是零矩阵，即0₁x₃=[0   0   0],右下角元素就是标量1。
        4.平移矩阵
            使用矩阵乘法表示对一个*点*进行平移变换：
                --                  -- -- --   --   --
                |   1   0   0    tx  | | x |   | x+tx| 
                |   0   1   0    ty  |·| y | = | y+ty| 
                |   0   0   1    tz  | | z |   | z+tz| 
                |   0   0   0    1   | | 1 |   | 1   | 
                --                  -- -- --   --   --
                最终，对点（x,y,z）平移了(tx,ty,tz)
            如果是对一个*向量*进行平移：
                --                  -- -- --   -- --
                |   1   0   0    tx  | | x |   | x | 
                |   0   1   0    ty  |·| y | = | y | 
                |   0   0   1    tz  | | z |   | z | 
                |   0   0   0    0   | | 0 |   | 0 | 
                --                  -- -- --   -- --
                最终，向量没有发生变化
            平移的逆矩阵是：
                --                  --
                |   1   0   0   -tx  |
                |   0   1   0   -ty  |
                |   0   0   1   -tz  |
                |   0   0   0    1   |
                --                  --
            可以看出，平移矩阵不是一个正交矩阵。
        5.缩放矩阵
            对一个模型沿空间的x轴、y轴和z轴进行缩放：
                对点：
                --                  -- -- --   --       --
                |   kx  0   0    0   | | x |   | (kx)*x  | 
                |   0   ky  0    0   |·| y | = | (ky)*y  | 
                |   0   0   kz   0   | | z |   | (kz)*z  | 
                |   0   0   0    1   | | 1 |   | 1       | 
                --                  -- -- --   --       --
                对向量：
                --                  -- -- --   --       --
                |   kx  0   0    0   | | x |   | (kx)*x  | 
                |   0   ky  0    0   |·| y | = | (ky)*y  | 
                |   0   0   kz   0   | | z |   | (kz)*z  | 
                |   0   0   0    1   | | 0 |   | 0       | 
                --                  -- -- --   --       --
                如果缩放系数kx=ky=kz，这样的缩放称为*统一缩放*(*uniform scale*),否则称为*非统一缩放*(*nonuniform scale*)
                从外观上看，统一缩放是扩大整个模型，而非统一缩放会拉伸或者挤压模型。
                此外，*统一缩放不会改变角度和比例信息*，而非统一缩放会改变模型相关的角度和比例。
            缩放矩阵的逆矩阵,对缩放进行还原：
                --                  --
                |  1/kx  0   0    0   |
                |   0  1/ky  0    0   |
                |   0   0   1/kz  0   |
                |   0   0    0    1   |
                --                  --
                缩放矩阵一般不是正交矩阵。
            上面的矩阵只适合于沿坐标轴方向进行缩放。如果希望能够在任意方向上进行缩放，就需要一个复合变换。
            其中一种方法的主要思想就是，先将缩放轴变换成标准坐标轴，然后在进行沿坐标轴的缩放，再使用逆变换得到原来的缩放轴朝向。
        6.旋转矩阵
            旋转是三种常见的变换矩阵中最复杂的一种。
            旋转操作需要指定一个旋转轴，这个旋转轴不一定是空间中的坐标轴。但本节中以绕着空间中的x轴、y轴或z轴进行旋转。
                把点绕x轴转θ度：
                             --                        --                          
                             |   1    0      0      0   |
                    Rx(θ)=   |   0  cosθ   -sinθ    0   |
                             |   0  sinθ    cosθ    0   |
                             |   0   0       0      1   |
                             --                        --
                把点绕y轴转θ度：
                             --                        --                          
                             |   cosθ    0    sinθ   0   |
                    Ry(θ)=   |     0     1     0     0   |
                             |   -sinθ   0    cosθ   0   |
                             |     0     0     0     1   |
                             --                        --
                把点绕z轴转θ度：
                             --                        --                          
                             |   cosθ    -sinθ   0   0   |
                    Rz(θ)=   |   sinθ     cosθ   0   0   |
                             |     0       0     1   0   |
                             |     0       0     0   1   |
                             --                        --
                旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。
                旋转矩阵是正交矩阵，而且多个旋转矩阵直接的串联同样是正交的。
        7.复合变换
            把平移、旋转和缩放组合起来，来形成一个复杂的变换过程。
            *变换的顺序是:缩放->旋转->平移*
                P(new) = M(transiation)M(rotation)M(scale)P(old)
                (使用列矩阵，阅读顺序从右到左)
            Unity中，如果旋转变换的时候，绕三个轴都有变换，那么，*旋转顺序是:zxy 先绕z轴->绕x轴->绕y轴*
            得到旋转的组合矩阵是：
                    M(rotation)=M(rotationZ)M(rotationX)M(rotationY)
            note:给定一个旋转顺序（eg.zxy）,以及它们对应的旋转角度（θx,θy,θz）,有两种坐标系可以选择
                .1.绕坐标系E下的z轴旋转θz，在坐标系E下再绕y轴旋转θy度，在坐标系E下再绕x轴旋转θx度。(坐标系不随之旋转)
                .2.坐标系E下，绕z轴旋转θz,再将坐标系E绕z轴旋转θ得到新坐标系E';在坐标系E'下绕x轴旋转θx度，再将坐标系E'绕x轴旋转θx得到新坐标系E'';
                  .在坐标系E''下绕y轴旋转θx度。即，在选中时，把坐标系一同旋转。(坐标系随之旋转)
                两种旋转方式得到的结果不一样。但是，如果把他们的旋转顺序颠倒一下，就结果就一样了。即：
                    第一种情况下的zxy，与第二种情况下的yxz旋转结果相同。
                Unity使用第一种方式（坐标系不随之旋转）
    5.坐标空间
        目标：对坐标空间进行变换。
        渲染可以理解为把模型顶点层层变换，最终变换到屏幕上的过程。
        1.Q:为什么需要不同的坐标空间
            A:不同情况下使用不同的坐标空间。有些概念只有在特定的坐标空间下才有意义，才更容易理解。
        2.坐标空间的变换
            在渲染流水管线中，往往需要把一个点或者方向矢量从一个坐标空间转换到另一个坐标空间。
            一个坐标空间是相对于另外一个坐标空间的，指定了1个原点和3个坐标轴的方向而形成的新的坐标空间。
            也就是说，每个坐标空间都有一个*父*(*parent*)坐标空间。
            *坐标空间的变换*实际上就是*父空间和子空间之间*对点和矢量进行变换。
            假设父坐标空间为P,子坐标空间为C。子坐标空间下的一点或者一个矢量Ac转换到父空间中为Ap;父空间中的一个点或者矢量Bp转换到子空间中为Bc,有：
                Ap=M(c->p)Ac    M(c->p)表示从子空间变换到父空间的变换矩阵
                Bc=M(p->c)Bp    M(p->c)表示从父空间变换到子空间的变换矩阵
                M(c->p)与M(p->c)互为*逆矩阵*,即：
                    M(c->p)·M(p->c)=I   (逆矩阵:MM⁻¹=M⁻¹M=I)
            1.求从子空间到父空间的变换矩阵M(c->p)
                引导：
                    Q:给定一个坐标空间以及其中一个点（a,b,c）,应该如果确定该点的位置？
                    A:
                        1.从坐标原点开始
                        2.向x轴方向移动a个单位
                        3.向y轴方向移动b个单位
                        4.向z轴方向移动c个单位
                类推:
                    Q:已知给定一个子坐标空间C的3个坐标轴在父坐标空间P下的表示Xc,Yc,Zc,以及其原点位置Oc。
                        当给定一个子坐标空间中的一点Ac=(a,b,c),求此点在父坐标空间下的位置Ap。
                    A:
                        1.从坐标原点开始
                            Oc
                        2.向x轴方向移动a个单位
                            Oc+a·Xc
                        3.向y轴方向移动b个单位
                            Oc+a·Xc+b·Yc
                        4.向z轴方向移动c个单位
                            Oc+a·Xc+b·Yc+c·Zc
                        所以，Ap=Oc+a·Xc+b·Yc+c·Zc
                                =(Xoc,Yoc,Zoc)+a(Xxc,Yxc,Zxc)+b(Xyc,Yyc,Zyc)+c(Xzc,Yzc,Zzc)
                                                  --              --  -- --
                                                  |  Xxc  Xyc  Xzc |  | a |  
                                =(Xoc,Yoc,Zoc) +  |  Yxc  Yyc  Yzc |  | b |     
                                                  |  Zxc  Zyc  Zzc |  | c | 
                                                  --              --  -- --
                                                  --             --  -- --
                                                  |  |    |    |  |  | a |  
                                =(Xoc,Yoc,Zoc) +  |  Xc   Yc   Zc |  | b | 
                                                  |  |    |    |  |  | c | 
                                                   --            --  -- --
                    ==>扩展到齐次空间：
                                                    --                --  -- --
                                                    |  |    |    |   0 |  | a |  
                                =(Xoc,Yoc,Zoc,1) +  |  Xc   Yc   Zc  0 |  | b | 
                                                    |  |    |    |   0 |  | c | 
                                                    |  C0   0    0   1 |  | 1 | 
                                                     --               --  -- --
                                 --                  -- --                --  -- --
                                 |   1   0   0    Xoc | |  |    |    |   0 |  | a |  
                                =|   0   1   0    Yoc | |  Xc   Yc   Zc  0 |  | b | 
                                 |   0   0   1    Zoc | |  |    |    |   0 |  | c | 
                                 |   0   0   0    1   | |  0    0    0   1 |  | 1 | 
                                 --                  --  --               --  -- --
                                  --                 --  -- --
                                  |  |    |    |  Xoc |  | a |  
                                = |  Xc   Yc   Zc Yoc |  | b | 
                                  |  |    |    |  Zoc |  | c | 
                                  |  0    0    0   1  |  | 1 | 
                                  --                 --  -- --
                     ===>推出变换矩阵：
                                        --                 --   --                 -- 
                                        |  |    |    |  Xoc |   |  |    |    |   |  | 
                                M(c->p)=|  Xc   Yc   Zc Yoc | = |  Xc   Yc   Zc  Oc | 
                                        |  |    |    |  Zoc |   |  |    |    |   |  | 
                                        |  0    0    0   1  |   |  0    0    0   1  | 
                                        --                 --   --                 -- 
                                Xc、Yc、Zc为3个坐标轴的矢量，Oc表示坐标原点位置
                                
                                同理可得,在P坐标空间：
                                        --                 --   --                 -- 
                                        |  |    |    |  Xop |   |  |    |    |   |  | 
                                M(p->c)=|  Xp   Yp   Zp Yop | = |  Xp   Yp   Zp  Op | 
                                        |  |    |    |  Zop |   |  |    |    |   |  | 
                                        |  0    0    0   1  |   |  0    0    0   1  | 
                                        --                 --   --                 -- 
                    由此，可以得知，如果已经知道了原点和坐标轴的矢量表示，可以直接写出变换矩阵；
                                    如果已经知道了变换矩阵，也可以直接得到原点和坐标轴矢量。
                    再次，由于原点的平移并不会影响坐标系的表示，坐标系只有坐标轴的单位矢量表示即可，因此在变换坐标系的时候，直接变换
                    坐标轴的单位矢量即可。因为和原点没有关系，所以，可以只抽出3x3坐标，作为变换矩阵。eg. 父控件的x坐标轴矢量 Xp=M(c->p)[1 0 0]T
                    可得*截取变换矩阵*：
                                            --              --
                                            |  |    |    |   |
                                    M(c->p)=|  Xc   Yc   Zc  |
                                            |  |    |    |   |
                                            --              --
                    在Shader中，经常使用截取变换矩阵来计算法线方向、光照方向的空间变换。
                    .获取在C空间表示的M(p->c)
                        已经知道，如果矩阵是正交矩阵的话，*正交矩阵*的逆矩阵等于它的转置矩阵。
                        已经知道，Xc,Yc,Zc三个坐标轴是互相垂直的，如果它们都是单位矢量的话，那么M(c->p)就是一个正交矩阵。
                        所以在C坐标空间：
                                            --              --
                                            |  ——    Xc   ——   |
                                    M(p->c)=|  ——    Yc   ——   |
                                            |  ——    Zc   ——   |
                                            --              --
    6.顶点坐标变换过程
        流水渲染管线中，一个顶点要经过多个坐标空间的变换才能最终显示到屏幕上。
        顶点一开始在*模型空间*,最后将被变换到*屏幕空间*中，得到真正的屏幕像素坐标。
        1.*模型空间*(*model space*)(左手坐标系)
            模型空间也被称为*对象空间*(*object space*)或*局部空间*(*local space*)
            模型空间中有一些常用的方向概念，例如，前(*forward*)、后(*back*)、左(*left*)、右(*right*)、上(*up*)、下(*down*)，被称为*自然方向*。
            模型空间中的坐标轴一般会使用这些自然方向。
            导入的模型信息中，包了每个顶点的坐标。这些坐标都是相对于模型空间中的远点（通常位于模型的中心）定义的。
        2.*世界空间*(*world space*)(左手坐标系)
            世界空间是一个特殊的坐标系，用于描述绝对位置。
            .顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间中。这个变换通常叫做*模型变换*(*model transform*)
                .总结步骤：
                    1.构造变换矩阵
                    2.对点进行变换
                根据Transform组件信息：
                cow没有父节点，Position是在世界空间中的位置。(此点在模型空间中是(0,0,0))
                cow的nose有父节点，在Inspector中显示的是其模型空间中的位置。
                    据定inspector，cow的transform信息为，position=(5,0,25),rotation=(0,150,0),scale=(2,2,2),
                    也就是说，模型到世界空间进行的变换是，
                    先缩放了(2,2,2),又进行了选择(0,150,0)，最后进行了平移(5,0,25)。据此构建变换矩阵：
                    (因此，这是一个从model->world变换的过程)
                        
                                        --                  -- --                        --  --                  --                        
                                        |   1   0   0    tx  | |   cosθ    0    sinθ   0   | |   kx  0   0    0   |
                     M(model->world)=   |   0   1   0    ty  | |     0     1     0     0   | |   0   ky  0    0   |
                                        |   0   0   1    tz  | |   -sinθ   0    cosθ   0   | |   0   0   kz   0   |
                                        |   0   0   0    1   | |     0     0     0     1   | |   0   0   0    1   |
                                        --                  -- --                        --  --                  --
                                        --                  -- --                        --  --                  --                        
                                        |   1   0   0    5   | |   cos150  0    sin150 0   | |   2   0   0    0   |
                                    =   |   0   1   0    0   | |     0     1     0     0   | |   0   2   0    0   |
                                        |   0   0   1    25  | |   -sin150 0    cos150 0   | |   0   0   2    0   |
                                        |   0   0   0    1   | |     0     0     0     1   | |   0   0   0    1   |
                                        --                  -- --                        --  --                  --
                                        --                  -- --                        --  --                  --                        
                                        |   1   0   0    5   | |   -0.866  0    0.5    0   | |   2   0   0    0   |
                                    =   |   0   1   0    0   | |     0     1     0     0   | |   0   2   0    0   |
                                        |   0   0   1    25  | |   -0.5    0    -0.866 0   | |   0   0   2    0   |
                                        |   0   0   0    1   | |     0     0     0     1   | |   0   0   0    1   |
                                        --                  -- --                        --  --                  --
                                        --                                -- 
                                        |   -1.732   0      1          5   | 
                                    =   |   0        2      0          0   | 
                                        |   -1       0      -1.732     25  | 
                                        |   0        0      0          1   | 
                                        --                                -- 
                获取了model矩阵,对nose进行模型变换：
                    P(world)=M(model->world)·P(model)
                    nose的相对位置（模型空间位置）为position=(0,2,4,1)，因此
                                --                                --   --   --   --       -- 
                                |   -1.732   0      1          5   |   |  0  |   |  9      | 
                    P(world)=   |   0        2      0          0   |   |  2  | = |  4      | 
                                |   -1       0      -1.732     25  |   |  4  |   |  18.072 | 
                                |   0        0      0          1   |   |  1  |   |  1      | 
                                --                                --   --   --   --       -- 
                    最终，得到nose的世界空间位置为position=（9,4,18.072,1）
        3.*观察空间*(*view space*)(右手坐标系)
            *观察空间*(*view space*)，也被称为*摄像机空间*(*camera space*)。
            观察空间中，摄像机位于原点，在Unity中，坐标轴方向,+x指向摄像机的右方，+y轴指向上方,+z指向摄像机的后方。(摄像机的前方指的是-z轴方向)
            note:观察空间和屏幕空间是不同的。观察空间是一个三维空间，而屏幕空间是一个二维空间。从观察空间到屏幕空间需要经过一个操作，叫做*投影*(*projection*)。
            .顶点变换的第二步，将顶点坐标从世界空间变换到观察空间中。这个变换通常叫做*观察变换*(*view transform*)
            为得到顶点在观察空间的位置，有两种方式：
                1.方法一：获得观察空间中的坐标轴到世界空间中的表示，构建出观察空间变换到世界空间的变换矩阵，再根据该矩阵得到世界空间到观察空间的变换矩阵。
                            (先获得view->world的变换矩阵，再求逆矩阵，得到world->view的矩阵)
                2.方法二：想象平移整个观察空间，让摄像机原点位于世界坐标的远点，坐标轴与世界空间中的坐标轴重合,从中得到变换矩阵。
                            (变换就是一个矩阵，从view->world的逆变换就是world->view的变换)

                使用方法二，摄像机在世界空间中的transform组件信息中，position=(0,10,-10),rotation=(30,0,0),scale=(1,1,1),
                即：
                    摄像机到世界空间中的变换是，先按（30,0,0）旋转，再按（0,10，-10）平移。
                为把摄像机重新移回到初始状态（摄像机位于世界空间的原点、坐标轴与世界空间的坐标轴重合）,需要对摄像机进行逆向变换，
                即：
                    从世界空间，到摄像机空间的变换是先按（0，-10,10）平移，移动回世界空间的原点，再按（-30,0,0）进行旋转，以便让坐标轴重合。因此，变换矩阵为：
                                     --                      --  --                  -- 
                                     |   1    0     0     0   |  |   1   0   0    tx  | 
                     M(world->view)= |   0  cosθ  -sinθ   0   |  |   0   1   0    ty  | 
                                     |   0  sinθ   cosθ   0   |  |   0   0   1    tz  | 
                                     |   0     0     0    1   |  |   0   0   0    1   | 
                                     --                      --  --                  -- 
                                     --                        --  --                  -- 
                                     |   1    0       0     0   |  |   1   0   0    0   | 
                                   = |   0  cos-30  -sin-30 0   |  |   0   1   0    -10 | 
                                     |   0  sin-30   cos-30 0   |  |   0   0   1    10  | 
                                     |   0    0        0    1   |  |   0   0   0    1   | 
                                     --                        --  --                  -- 
                                     --                        --  --                  -- 
                                     |   1    0       0     0   |  |   1   0   0    0   | 
                                   = |   0  0.866   -0.5    0   |  |   0   1   0    -10 | 
                                     |   0   0.5     0.866  0   |  |   0   0   1    10  | 
                                     |   0    0       0     1   |  |   0   0   0    1   | 
                                     --                        --  --                  -- 
                                     --                        --  
                                     |   1    0       0     0   |  
                                   = |   0  0.866   -0.5   -3.66|  
                                     |   0  -0.5     0.866 13.66|  
                                     |   0    0       0     1   |  
                                     --                        --  
                但是，由于观察空间使用的是右手坐标系,因此，要最z分量取反操作(z方向取反)：
                     M(world->view)= M(negate)M(world->view)
                                     --                        --  --                        --  
                                     |   1    0       0     0   |  |   1    0       0     0   |  
                                   = |   0    1       0     0   |  |   0  0.866   -0.5   -3.66|  
                                     |   0    0      -1     0   |  |   0  -0.5     0.866 13.66|  
                                     |   0    0       0     0   |  |   0    0       0     1   |  
                                     --                        --  --                        --  
                                     --                          --  
                                     |   1    0       0       0   |  
                                   = |   0  0.866   -0.5     -3.66|  
                                     |   0   0.5    -0.866  -13.66|  
                                     |   0    0       0       1   |  
                                     --                          --  
                对nose的world坐标进行变换：(nose worldPos=（9,4,18.072,1))

                        P(view)= M(world->view)P(world)
                                 --                          --  --      --   --      --
                                 |   1    0       0       0   |  |   9    |   |   9    |
                               = |   0  0.866   -0.5     -3.66|  |   4    |  =|  8.84  |
                                 |   0   0.5    -0.866  -13.66|  | 18.072 |   | -27.31 |
                                 |   0    0       0       1   |  |   1    |   |   1    |
                                 --                          --  --      --   --      --
                    得到nose在观察空间的位置坐标为viewPos=(9,8.84,-27.31)
        4.*裁剪空间*(*clip space*,*齐次裁剪空间*)
            接下来，将顶点从观察空间变换到裁剪空间。这个用于变换的矩阵叫做*裁剪矩阵*(*clip matrix*),也被称为*投影矩阵*(*projection matrix*)。
            裁剪空间的大小由*视锥体*(*view frustum*)来决定。
            *视锥体*指的是空间中的一块区域，摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为*裁剪平面*(*clip planes*)。
            视锥体有两种投影类型：*正交投影*(*orthographic projection*)和*透视投影*(*perspectiv projection*)
            裁剪平面中的*近裁剪平面*(*near clip plane*)和*远裁剪平面*(*far clip plane*)决定了摄像机可以看到的深度范围。
            通过投影矩阵，将顶点变换到裁剪空间中。
            .投影矩阵有两个目的：
                1.为投影做准备
                    投影矩阵并没有真正进行投影工作，而是在为投影做准备。真正的投影发生在后面的*齐次除法*(*homogeneous division*)过程中。
                    经过投影矩阵的变换后，顶点的w分量将会有特殊的意义。
                    投影是个降为的过程，将顶点从三维空间降到二维屏幕空间。通过齐次除法得到二维空间坐标。
                2.对x、y、z分量进行缩放。
                    经过投影矩阵的缩放后，可以直接使用w分量作为一个范围值。如果x、y、z分量都在这个范围内，就说明该顶点位于裁剪空间内。
            投影的处理：
            1.透视投影
                视锥体定义了场景中的一块三维空间，所有位于这块空间内的物体将会被渲染，否则就会被*剔除*或者*裁剪*。
                Unity中，Camera组件：
                    Field of View (FOV):改变视锥体竖直方向的张开角度.
                    Clipping Planes中，Near和Far参数可用控制视锥体的近裁剪平面和远裁剪平面。
                    由此，可以求得视锥体近裁剪屏幕和远裁剪平面的高度Height：
                        nearClipPlaneHeight=2·Near·tan(FOV/2)
                        farClipPlaneHeight=2·Far·tan(FOV/2)
                    视锥体的横向width由通过*摄像机的横纵比*(*Aspect*)得到。
                    Unity中摄像机的横纵比由Game视图的横纵比和ViewPort Rect中的W和H属性共同决定：
                        Aspect=(nearClipPlaneWidth/nearClipPanelHeight)
                        Aspect=(farClipPlaneWidth/farClipPanelHeight)
                    Unity中，根据已知的Near、Far、FOV和Aspect的值来确定投影矩阵：
                                         --                                                                                                --  
                                         | (cot(FOV/2))/Aspect      0                   0                           0                       |  
                             M(frustum)= |   0                    cot(FOV/2)            0                           0                       |  
                                         |   0                      0         -((Far+Near)/(Far-Near))      -((2·Near·Far)/(Far-Near))      |  
                                         |   0                      0                   0                           0                       |
                                         --                                                                                                --  
                            正割:secθ=1/(cosθ) 
                            余割:cscθ=1/(sin) 
                            余切:cotθ=(cosθ/sinθ)=(cscθ/secθ)
                        note:这里的投影矩阵是以Unity中的坐标系为参考的，即观察空间为右手坐标系，使用列矩阵在矩阵右侧进行相乘 且变换后，z分类范围在[-w,w]之间。
                        note:在DirectX中，变换后z分类的范围是在[0,w]之间，因此投影矩阵也不一样。
                    顶点和投影矩阵相乘，得到顶点在裁剪空间中的位置：
                        P(clip) = M(frustum)·P(view)
                                 --                                                                                            --  -- --
                                 | (cot(FOV/2))/Aspect      0                   0                           0                   |  | x |
                                =|   0                    cot(FOV/2)            0                           0                   |  | y |
                                 |   0                      0         -((Far+Near)/(Far-Near))      -((2·Near·Far)/(Far-Near))  |  | z |
                                 |   0                      0                   0                           0                   |  | 1 |
                                 --                                                                                            --  -- --
                                 --                                                   --  
                                 |                   x(cot(FOV/2)/Aspect)              |  
                                =|                     y(cot(FOV/2)                    |  
                                 | -z((Far+Near)/(Far-Near))-((2·Near·Far)/(Far-Near)) |  
                                 |                           -z                        |  
                                 --                                                   --
                    .投影矩阵的本质就是对x、y、z和w分量进行了不同程度的缩放（z分量还做了一个平移），目的在于方便裁剪.
                    .此时顶点的w分量不再是1,而是-z。
                    .如果一定顶点在视锥体内，那么变换后的坐标必须满足：
                        -w  <=  x   <=w
                        -w  <=  y   <=w
                        -w  <=  z   <=w
                        任何不满足上述条件的图元都需要被*剔除*或者*裁剪*。
                    .裁剪矩阵还改变了空间的旋向性：空间从右手坐标系变换到了左手坐标系。离相机越远，z值将越大。
            2.正交投影
                Unity中，通过Camera组件：
                    Size:视锥体竖直方向上高度的半，即
                        nearClipPanelHeight=2·Size
                        farClipPanelHeight = nearClipPanelHeight
                
                        nearClipPlaneWidth=Aspect·nearClipPanelHeight
                        farClipPlaneHeight=nearClipPlaneWidth
                                     --                                                                                                --  
                                     | 1/(Aspect·Size)          0                   0                           0                       |  
                           M(prtho)= |   0                    1/Size                0                           0                       |  
                                     |   0                      0         -(2/(Far-Near))                 -((Near+Far)/(Far-Near))      |  
                                     |   0                      0                   0                           1                       |  
                                     --                                                                                                --  
                        P(clip) = M(prtho)·P(view)
                                 --                                                                                                -- -- --
                                 | 1/(Aspect·Size)          0                   0                           0                       | | x |
                                =|   0                    1/Size                0                           0                       | | y |
                                 |   0                      0         -(2/(Far-Near))                 -((Near+Far)/(Far-Near))      | | z |
                                 |   0                      0                   0                           1                       | | 1 |
                                 --                                                                                                -- -- --
                                 --                                              --  
                                 |                   x/(Aspect·Size)              |  
                                =|                     y(Size)                    |  
                                 |       -(2z/(Far-Near))-((Far+Near)/(Far-Near)) |  
                                 |                           1                    |
                                 --                                              -- 
        3.*屏幕空间*(*screen space*)


<<Unity Shaders and Effects Cookbook>>                                                           
note:很好的书。不是按照基础→应用的方式讲过的。按照应用→原理方式讲述。讲解了创建着色器和后期特效模板测试结束。与应用结合紧密。
        
